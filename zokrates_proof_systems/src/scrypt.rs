use crate::Scheme;
use serde::{de::DeserializeOwned, Serialize};
use zokrates_common::helpers::CurveParameter;
use zokrates_field::{Bn128Field, Bls12_381Field, Field};

pub trait ScryptCompatibleField: Field {}
impl ScryptCompatibleField for Bn128Field {}
impl ScryptCompatibleField for Bls12_381Field {}
pub trait ScryptCompatibleScheme<T: ScryptCompatibleField>: Scheme<T> {
    type Proof: From<Self::ProofPoints> + Serialize + DeserializeOwned + Clone;

    fn export_scrypt_verifier(vk: Self::VerificationKey, alpha_g1_beta_g2: String, curve_parameter: CurveParameter) -> String;
}


pub fn scrypt_pairing_lib_bn128() -> String {
    let bn256_lib = r#"
type FQ = int;

struct FQ2 {
    FQ x;
    FQ y;
}

struct FQ6 {
    FQ2 x;
    FQ2 y;
    FQ2 z;
}

struct CurvePoint {
    FQ x;
    FQ y;
    FQ z;
    FQ t;
}

struct TwistPoint {
    FQ2 x;
    FQ2 y;
    FQ2 z;
    FQ2 t;
}

// These two are just to make it easier for users to interface with the code
// by not having them to deal with z and t coords.
struct G1Point {
    FQ x;
    FQ y;
}

struct G2Point {
    FQ2 x;
    FQ2 y;
}

// FQ12 implements the field of size p¹² as a quadratic extension of FQ6
// where ω²=τ.
struct FQ12 {
    FQ6 x;
    FQ6 y;
}

library BN256 {

    // Curve bits:
    static const int CURVE_BITS = 256; 
    static const int CURVE_BITS_P8 = 264; // +8 bits
    static const int CURVE_BITS_P8_DIV12 = 88;

    // Key int size:
    static const int S = 33;    // 32 bytes plus sign byte
    static const bytes mask = reverseBytes(num2bin(1, 33), 33);
    static const bytes zero = reverseBytes(num2bin(0, 33), 33);

    // Generator of G1:
    static const CurvePoint G1 = {1, 2, 1, 1};

    // Generator of G2:
    static const TwistPoint G2 = {
        {
            0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,
            0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed
        },
        {
            0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,
            0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa
        },
        {0, 1},
        {0, 1}
    };

    static const FQ2 FQ2Zero = {0, 0};
    static const FQ2 FQ2One = {0, 1};

    static const FQ6 FQ6Zero = {
        FQ2Zero, FQ2Zero, FQ2Zero
    };

    static const FQ6 FQ6One = {
        FQ2Zero, FQ2Zero, FQ2One
    };

    static const FQ12 FQ12Zero = {FQ6Zero, FQ6Zero};
    static const FQ12 FQ12One = {FQ6Zero, FQ6One};

    // Curve field modulus:
    static int P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;

    // xiToPMinus1Over6 is ξ^((p-1)/6) where ξ = i+9.
    static const FQ2 xiToPMinus1Over6 = {
        0x246996f3b4fae7e6a6327cfe12150b8e747992778eeec7e5ca5cf05f80f362ac,
        0x1284b71c2865a7dfe8b99fdd76e68b605c521e08292f2176d60b35dadcc9e470
    };

    // xiTo2PMinus2Over3 is ξ^((2p-2)/3) where ξ = i+9.
    static const FQ2 xiTo2PMinus2Over3 = {
        0x2c145edbe7fd8aee9f3a80b03b0b1c923685d2ea1bdec763c13b4711cd2b8126,
        0x05b54f5e64eea80180f3c0b75a181e84d33365f7be94ec72848a1f55921ea762
    };

    // xiToPMinus1Over2 is ξ^((p-1)/2) where ξ = i+9.
    static const FQ2 xiToPMinus1Over2 = {
        0x07c03cbcac41049a0704b5a7ec796f2b21807dc98fa25bd282d37f632623b0e3,
        0x063cf305489af5dcdc5ec698b6e2f9b9dbaae0eda9c95998dc54014671a0135a
    };

    // xiToPMinus1Over3 is ξ^((p-1)/3) where ξ = i+9.
    static const FQ2 xiToPMinus1Over3 = {
        0x16c9e55061ebae204ba4cc8bd75a079432ae2a1d0b7c9dce1665d51c640fcba2,
        0x2fb347984f7911f74c0bec3cf559b143b78cc310c2c3330c99e39557176f553d
    };

    // xiTo2PSquaredMinus2Over3 is ξ^((2p²-2)/3) where ξ = i+9 (a cubic root of unity, mod p).
    static const FQ xiTo2PSquaredMinus2Over3 = 0x59e26bcea0d48bacd4f263f1acdb5c4f5763473177fffffe;
    
    // xiToPSquaredMinus1Over3 is ξ^((p²-1)/3) where ξ = i+9.
    static const FQ xiToPSquaredMinus1Over3 = 0x30644e72e131a0295e6dd9e7e0acccb0c28f069fbb966e3de4bd44e5607cfd48;

    // xiToPSquaredMinus1Over6 is ξ^((1p²-1)/6) where ξ = i+9 (a cubic root of -1, mod p).
    static const FQ xiToPSquaredMinus1Over6 = 0x30644e72e131a0295e6dd9e7e0acccb0c28f069fbb966e3de4bd44e5607cfd49;

    static function modReduce(int k, int modulus) : int {
        int res = k % modulus;
        return (res < 0) ? res + modulus : res;
    }

    static function modFQ2(FQ2 t0): FQ2 {
        t0.x = BN256.modReduce(t0.x, BN256.P);
        t0.y = BN256.modReduce(t0.y, BN256.P);
        return t0;
    }

    static function modFQ12(FQ12 t0): FQ12 {
        t0.x.x.x = BN256.modReduce(t0.x.x.x, BN256.P);
        t0.x.x.y = BN256.modReduce(t0.x.x.y, BN256.P);
        t0.x.y.x = BN256.modReduce(t0.x.y.x, BN256.P);
        t0.x.y.y = BN256.modReduce(t0.x.y.y, BN256.P);
        t0.x.z.x = BN256.modReduce(t0.x.z.x, BN256.P);
        t0.x.z.y = BN256.modReduce(t0.x.z.y, BN256.P);
        t0.y.x.x = BN256.modReduce(t0.y.x.x, BN256.P);
        t0.y.x.y = BN256.modReduce(t0.y.x.y, BN256.P);
        t0.y.y.x = BN256.modReduce(t0.y.y.x, BN256.P);
        t0.y.y.y = BN256.modReduce(t0.y.y.y, BN256.P);
        t0.y.z.x = BN256.modReduce(t0.y.z.x, BN256.P);
        t0.y.z.y = BN256.modReduce(t0.y.z.y, BN256.P);
        return t0;
    }
    
    static function modCurvePoint(CurvePoint t0): CurvePoint {
        t0.x = BN256.modReduce(t0.x, BN256.P);
        t0.y = BN256.modReduce(t0.y, BN256.P);
        t0.z = BN256.modReduce(t0.z, BN256.P);
        t0.t = BN256.modReduce(t0.t, BN256.P);
        return t0;
    }
    
    static function modTwistPoint(TwistPoint t0): TwistPoint {
        t0.x.x = BN256.modReduce(t0.x.x, BN256.P);
        t0.x.y = BN256.modReduce(t0.x.y, BN256.P);
        t0.y.x = BN256.modReduce(t0.y.x, BN256.P);
        t0.y.y = BN256.modReduce(t0.y.y, BN256.P);
        t0.z.x = BN256.modReduce(t0.z.x, BN256.P);
        t0.z.y = BN256.modReduce(t0.z.y, BN256.P);
        t0.t.x = BN256.modReduce(t0.t.x, BN256.P);
        t0.t.y = BN256.modReduce(t0.t.y, BN256.P);
        return t0;
    }

    static function mulFQ2(FQ2 a, FQ2 b) : FQ2 {
        int tx = a.x * b.y;
        int t =  b.x * a.y;
        int tx_2 = tx + t;

        int ty = a.y * b.y;
        int t_2 = a.x * b.x;
        int ty_2 = ty - t_2;
        
        return {modReduce(tx_2, P), modReduce(ty_2, P)};
    }

    static function mulXiFQ2(FQ2 a) : FQ2 {
        // (xi+y)(i+3) = (9x+y)i+(9y-x)
        FQ tx = (a.x << 3) + a.x + a.y;
        FQ ty = (a.y << 3) + a.y - a.x;
        return {modReduce(tx, P), modReduce(ty, P)};
    }

    static function mulScalarFQ2(FQ2 a, int scalar) : FQ2 {
        return {
            modReduce(a.x * scalar, P),
            modReduce(a.y * scalar, P)
        };
    }

    static function addFQ2(FQ2 a, FQ2 b) : FQ2 {
        return {
            modReduce(a.x + b.x, P), 
            modReduce(a.y + b.y, P)
        };
    }

    static function subFQ2(FQ2 a, FQ2 b) : FQ2 {
        return {
            modReduce(a.x - b.x, P),
            modReduce(a.y - b.y, P)
        };
    }

    static function negFQ2(FQ2 a) : FQ2 {
        return {
            modReduce(a.x * -1, P), 
            modReduce(a.y * -1, P)
        };
    }

    static function conjugateFQ2(FQ2 a) : FQ2 {
        return {
            modReduce(a.x * -1, P), 
            modReduce(a.y, P)
        };
    }

    static function doubleFQ2(FQ2 a) : FQ2 {
        return {
            modReduce(a.x * 2, P),
            modReduce(a.y * 2, P)
        };
    }

    static function squareFQ2(FQ2 a) : FQ2 {
        int tx = a.y - a.x;
        int ty = a.x + a.y;
        int ty_2 = ty * tx;

        int tx_2 = (a.x * a.y) * 2;

        return {modReduce(tx_2, P), modReduce(ty_2, P)};
    }

    static function modInverseBranchlessP(int x) : int {
        asm {
47fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e6430 OP_SWAP OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_MUL OP_OVER OP_MOD OP_DUP OP_TOALTSTACK OP_DUP OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_FROMALTSTACK OP_MUL OP_OVER OP_MOD OP_NIP
        }
    }

    static function inverseFQ2(FQ2 a) : FQ2 {
        int t2 = a.y * a.y; 
        int t1 = (a.x * a.x) + t2;

        int inv = modInverseBranchlessP(t1);

        int axNeg = a.x * -1;

        return {
            modReduce(axNeg * inv, P),
            modReduce(a.y * inv, P)
        };
    }

    static function mulFQ6(FQ6 a, FQ6 b) : FQ6 {
        // "Multiplication and Squaring on Pairing-Friendly Fields"
        // Section 4, Karatsuba method.
        // http://eprint.iacr.org/2006/471.pdf

        FQ2 v0 = mulFQ2(a.z, b.z);
        FQ2 v1 = mulFQ2(a.y, b.y);
        FQ2 v2 = mulFQ2(a.x, b.x);

        FQ2 t0 = addFQ2(a.x, a.y);
        FQ2 t1 = addFQ2(b.x, b.y);
        FQ2 tz = mulFQ2(t0, t1);

        tz = subFQ2(tz, v1);
        tz = subFQ2(tz, v2);
        tz = mulXiFQ2(tz);
        tz = addFQ2(tz, v0);

        t0 = addFQ2(a.y, a.z);
        t1 = addFQ2(b.y, b.z);
        
        FQ2 ty = mulFQ2(t0, t1);
        ty = subFQ2(ty, v0);
        ty = subFQ2(ty, v1);
        t0 = mulXiFQ2(v2);
        ty = addFQ2(ty, t0);

        t0 = addFQ2(a.x, a.z);
        t1 = addFQ2(b.x, b.z);
        FQ2 tx = mulFQ2(t0, t1);
        tx = subFQ2(tx, v0);
        tx = addFQ2(tx, v1);
        tx = subFQ2(tx, v2);

        return {tx, ty, tz};
    }

    static function doubleFQ6(FQ6 a) : FQ6 {
        return {
            doubleFQ2(a.x),
            doubleFQ2(a.y),
            doubleFQ2(a.z)
        };
    }

    static function mulScalarFQ6(FQ6 a, FQ2 scalar) : FQ6 {
        return {
            mulFQ2(a.x, scalar),
            mulFQ2(a.y, scalar),
            mulFQ2(a.z, scalar)
        };
    }

    static function addFQ6(FQ6 a, FQ6 b) : FQ6 {
        return {
            addFQ2(a.x, b.x),
            addFQ2(a.y, b.y),
            addFQ2(a.z, b.z)
        };
    }

    static function subFQ6(FQ6 a, FQ6 b) : FQ6 {
        return {
            subFQ2(a.x, b.x),
            subFQ2(a.y, b.y),
            subFQ2(a.z, b.z)
        };
    }

    static function negFQ6(FQ6 a) : FQ6 {
        return {
            negFQ2(a.x),
            negFQ2(a.y),
            negFQ2(a.z)
        };
    }

    static function squareFQ6(FQ6 a) : FQ6 {
        FQ2 v0 = squareFQ2(a.z);
        FQ2 v1 = squareFQ2(a.y);
        FQ2 v2 = squareFQ2(a.x);

        FQ2 c0 = addFQ2(a.x, a.y);
        c0 = squareFQ2(c0);
        c0 = subFQ2(c0, v1);
        c0 = subFQ2(c0, v2);
        c0 = mulXiFQ2(c0);
        c0 = addFQ2(c0, v0);

        FQ2 c1 = addFQ2(a.y, a.z);
        c1 = squareFQ2(c1);
        c1 = subFQ2(c1, v0);
        c1 = subFQ2(c1, v1);
        FQ2 xiV2 = mulXiFQ2(v2);
        c1 = addFQ2(c1, xiV2);

        FQ2 c2 = addFQ2(a.x, a.z);
        c2 = squareFQ2(c2);
        c2 = subFQ2(c2, v0);
        c2 = addFQ2(c2, v1);
        c2 = subFQ2(c2, v2);

        return {c2, c1, c0};
    }

    static function mulTauFQ6(FQ6 a) : FQ6 {
        // MulTau computes τ·(aτ²+bτ+c) = bτ²+cτ+aξ
        return {
            a.y,
            a.z,
            mulXiFQ2(a.x)
        };
    }

    static function inverseFQ6(FQ6 a) : FQ6 {
        // See "Implementing cryptographic pairings", M. Scott, section 3.2.
        // ftp://136.206.11.249/pub/crypto/pairings.pdf

        // Here we can give a short explanation of how it works: let j be a cubic root of
        // unity in GF(p²) so that 1+j+j²=0.
        // Then (xτ² + yτ + z)(xj²τ² + yjτ + z)(xjτ² + yj²τ + z)
        // = (xτ² + yτ + z)(Cτ²+Bτ+A)
        // = (x³ξ²+y³ξ+z³-3ξxyz) = F is an element of the base field (the norm).
        //
        // On the other hand (xj²τ² + yjτ + z)(xjτ² + yj²τ + z)
        // = τ²(y²-ξxz) + τ(ξx²-yz) + (z²-ξxy)
        //
        // So that's why A = (z²-ξxy), B = (ξx²-yz), C = (y²-ξxz)

        FQ2 A = squareFQ2(a.z);
        FQ2 t1 = mulFQ2(a.x, a.y);
        t1 = mulXiFQ2(t1);
        A = subFQ2(A, t1);
        
        FQ2 B = squareFQ2(a.x);
        B = mulXiFQ2(B);
        t1 = mulFQ2(a.y, a.z);
        B = subFQ2(B, t1);

        FQ2 C = squareFQ2(a.y);
        t1 = mulFQ2(a.x, a.z);
        C = subFQ2(C, t1);
        
        FQ2 F = mulFQ2(C, a.y);
        F = mulXiFQ2(F);
        t1 = mulFQ2(A, a.z);
        F = addFQ2(F, t1);
        t1 = mulFQ2(B, a.x);
        t1 = mulXiFQ2(t1);
        F = addFQ2(F, t1);

        F = inverseFQ2(F);

        return {
            mulFQ2(C, F),
            mulFQ2(B, F),
            mulFQ2(A, F)
        };
    }

    static function mulScalarFQ12(FQ12 a, FQ6 b) : FQ12 {
        return {
            mulFQ6(a.x, b),
            mulFQ6(a.y, b)
        };
    }

    static function inverseFQ12(FQ12 a) : FQ12 {
        // See "Implementing cryptographic pairings", M. Scott, section 3.2.
        // ftp://136.206.11.249/pub/crypto/pairings.pdf

        FQ6 t1 = squareFQ6(a.x);
        FQ6 t2 = squareFQ6(a.y);
        FQ6 t1_2 = mulTauFQ6(t1);
        FQ6 t1_3 = subFQ6(t2, t1_2);
        FQ6 t2_2 = inverseFQ6(t1_3);

        FQ12 e = {
            negFQ6(a.x),
            a.y
        };
        
        return mulScalarFQ12(e, t2_2);
    }

    static function mulFQ12(FQ12 a, FQ12 b) : FQ12 {
        asm {
OP_13 OP_PICK OP_OVER OP_MUL OP_2 OP_PICK OP_14 OP_PICK OP_MUL OP_ADD OP_13 OP_PICK OP_2 OP_PICK OP_MUL OP_15 OP_PICK OP_4 OP_PICK OP_MUL OP_SUB 11 OP_PICK OP_5 OP_PICK OP_MUL OP_6 OP_PICK 12 OP_PICK OP_MUL OP_ADD 11 OP_PICK OP_6 OP_PICK OP_MUL 13 OP_PICK OP_8 OP_PICK OP_MUL OP_SUB 15 OP_PICK OP_9 OP_PICK OP_MUL OP_10 OP_PICK 16 OP_PICK OP_MUL OP_ADD 15 OP_PICK OP_10 OP_PICK OP_MUL 17 OP_PICK OP_12 OP_PICK OP_MUL OP_SUB 17 OP_PICK 16 OP_PICK OP_ADD 17 OP_PICK 16 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_5 OP_PICK OP_SUB OP_SWAP OP_4 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_SWAP OP_7 OP_PICK OP_ADD OP_SWAP OP_6 OP_PICK OP_ADD 17 OP_PICK 16 OP_PICK OP_ADD 17 OP_PICK 16 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_9 OP_PICK OP_SUB OP_SWAP OP_8 OP_PICK OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_5 OP_PICK OP_5 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD 1b OP_PICK 18 OP_PICK OP_ADD 1b OP_PICK 18 OP_PICK OP_ADD 11 OP_PICK OP_14 OP_PICK OP_ADD 11 OP_PICK OP_14 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_11 OP_ROLL OP_SUB OP_SWAP OP_10 OP_ROLL OP_SUB OP_SWAP OP_9 OP_ROLL OP_ADD OP_SWAP OP_8 OP_ROLL OP_ADD OP_SWAP OP_7 OP_ROLL OP_SUB OP_SWAP OP_6 OP_ROLL OP_SUB 19 OP_PICK OP_13 OP_PICK OP_MUL OP_14 OP_PICK 1a OP_PICK OP_MUL OP_ADD 19 OP_PICK OP_14 OP_PICK OP_MUL 1b OP_PICK OP_16 OP_PICK OP_MUL OP_SUB 1d OP_PICK 11 OP_PICK OP_MUL 12 OP_PICK 1e OP_PICK OP_MUL OP_ADD 1d OP_PICK 12 OP_PICK OP_MUL 1f OP_PICK 14 OP_PICK OP_MUL OP_SUB 21 OP_PICK 15 OP_PICK OP_MUL 16 OP_PICK 22 OP_PICK OP_MUL OP_ADD 21 OP_PICK 16 OP_PICK OP_MUL 23 OP_PICK 18 OP_PICK OP_MUL OP_SUB 23 OP_PICK 22 OP_PICK OP_ADD 23 OP_PICK 22 OP_PICK OP_ADD 19 OP_PICK 18 OP_PICK OP_ADD 19 OP_PICK 18 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_5 OP_PICK OP_SUB OP_SWAP OP_4 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_SWAP OP_7 OP_PICK OP_ADD OP_SWAP OP_6 OP_PICK OP_ADD 23 OP_PICK 22 OP_PICK OP_ADD 23 OP_PICK 22 OP_PICK OP_ADD 19 OP_PICK 18 OP_PICK OP_ADD 19 OP_PICK 18 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_9 OP_PICK OP_SUB OP_SWAP OP_8 OP_PICK OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_5 OP_PICK OP_5 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD 27 OP_PICK 24 OP_PICK OP_ADD 27 OP_PICK 24 OP_PICK OP_ADD 1d OP_PICK 1a OP_PICK OP_ADD 1d OP_PICK 1a OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_11 OP_ROLL OP_SUB OP_SWAP OP_10 OP_ROLL OP_SUB OP_SWAP OP_9 OP_ROLL OP_ADD OP_SWAP OP_8 OP_ROLL OP_ADD OP_SWAP OP_7 OP_ROLL OP_SUB OP_SWAP OP_6 OP_ROLL OP_SUB OP_3 OP_PICK OP_3 OP_PICK OP_7 OP_PICK OP_7 OP_PICK OP_5 OP_PICK OP_5 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB 29 OP_PICK 24 OP_PICK OP_ADD 29 OP_PICK 24 OP_PICK OP_ADD 29 OP_PICK 24 OP_PICK OP_ADD 29 OP_PICK 24 OP_PICK OP_ADD 29 OP_PICK 24 OP_PICK OP_ADD 29 OP_PICK 24 OP_PICK OP_ADD 23 OP_PICK 1e OP_PICK OP_ADD 23 OP_PICK 1e OP_PICK OP_ADD 23 OP_PICK 1e OP_PICK OP_ADD 23 OP_PICK 1e OP_PICK OP_ADD 23 OP_PICK 1e OP_PICK OP_ADD 23 OP_PICK 1e OP_PICK OP_ADD OP_7 OP_PICK OP_OVER OP_MUL OP_2 OP_PICK OP_8 OP_PICK OP_MUL OP_ADD OP_7 OP_PICK OP_2 OP_PICK OP_MUL OP_9 OP_PICK OP_4 OP_PICK OP_MUL OP_SUB OP_11 OP_PICK OP_5 OP_PICK OP_MUL OP_6 OP_PICK OP_12 OP_PICK OP_MUL OP_ADD OP_11 OP_PICK OP_6 OP_PICK OP_MUL OP_13 OP_PICK OP_8 OP_PICK OP_MUL OP_SUB OP_15 OP_PICK OP_9 OP_PICK OP_MUL OP_10 OP_PICK OP_16 OP_PICK OP_MUL OP_ADD OP_15 OP_PICK OP_10 OP_PICK OP_MUL 11 OP_PICK OP_12 OP_PICK OP_MUL OP_SUB 11 OP_PICK OP_16 OP_PICK OP_ADD 11 OP_PICK OP_16 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_5 OP_PICK OP_SUB OP_SWAP OP_4 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_SWAP OP_7 OP_PICK OP_ADD OP_SWAP OP_6 OP_PICK OP_ADD 11 OP_ROLL OP_16 OP_PICK OP_ADD 11 OP_ROLL OP_16 OP_PICK OP_ADD OP_13 OP_ROLL OP_12 OP_PICK OP_ADD OP_13 OP_ROLL OP_12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_9 OP_PICK OP_SUB OP_SWAP OP_8 OP_PICK OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_5 OP_PICK OP_5 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD 11 OP_ROLL OP_16 OP_ROLL OP_ADD OP_16 OP_ROLL OP_16 OP_ROLL OP_ADD OP_15 OP_ROLL OP_14 OP_ROLL OP_ADD OP_14 OP_ROLL OP_14 OP_ROLL OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_11 OP_ROLL OP_SUB OP_SWAP OP_10 OP_ROLL OP_SUB OP_SWAP OP_9 OP_ROLL OP_ADD OP_SWAP OP_8 OP_ROLL OP_ADD OP_SWAP OP_7 OP_ROLL OP_SUB OP_SWAP OP_6 OP_ROLL OP_SUB OP_SWAP 13 OP_PICK OP_SUB OP_SWAP 12 OP_PICK OP_SUB OP_3 OP_ROLL 15 OP_PICK OP_SUB OP_3 OP_ROLL 14 OP_PICK OP_SUB OP_5 OP_ROLL 17 OP_PICK OP_SUB OP_5 OP_ROLL 16 OP_PICK OP_SUB OP_5 OP_ROLL OP_13 OP_ROLL OP_SUB OP_5 OP_ROLL OP_12 OP_ROLL OP_SUB OP_5 OP_ROLL OP_13 OP_ROLL OP_SUB OP_5 OP_ROLL OP_12 OP_ROLL OP_SUB OP_5 OP_ROLL OP_13 OP_ROLL OP_SUB OP_5 OP_ROLL OP_12 OP_ROLL OP_SUB OP_13 OP_ROLL OP_12 OP_ROLL OP_ADD OP_12 OP_ROLL OP_12 OP_ROLL OP_ADD OP_13 OP_ROLL OP_12 OP_ROLL OP_ADD OP_12 OP_ROLL OP_12 OP_ROLL OP_ADD OP_13 OP_ROLL OP_12 OP_ROLL OP_ADD OP_12 OP_ROLL OP_12 OP_ROLL OP_ADD
        }
    }

    static function OLDmulFQ12(FQ12 a, FQ12 b) : FQ12 {
        FQ6 tx = mulFQ6(a.x, b.y);
        FQ6 t = mulFQ6(b.x, a.y);
        FQ6 tx2 = addFQ6(tx, t);

        FQ6 ty = mulFQ6(a.y, b.y);
        FQ6 t2 = mulFQ6(a.x, b.x);
        FQ6 t3 = mulTauFQ6(t2);
        
        return {tx2, addFQ6(ty, t3)};
    }

    static function frobeniusFQ6(FQ6 a) : FQ6 {
        return {
            mulFQ2(conjugateFQ2(a.x), xiTo2PMinus2Over3),
            mulFQ2(conjugateFQ2(a.y), xiToPMinus1Over3),
            conjugateFQ2(a.z)
        };
    }

    static function frobeniusP2FQ6(FQ6 a) : FQ6 {
        // FrobeniusP2 computes (xτ²+yτ+z)^(p²) = xτ^(2p²) + yτ^(p²) + z
        return {
            // τ^(2p²) = τ²τ^(2p²-2) = τ²ξ^((2p²-2)/3)
            mulScalarFQ2(a.x, xiTo2PSquaredMinus2Over3),
            // τ^(p²) = ττ^(p²-1) = τξ^((p²-1)/3)
            mulScalarFQ2(a.y, xiToPSquaredMinus1Over3),
            a.z
        };
    }

    static function mulGFP(FQ6 a, int b) : FQ6 {
        return {
            mulScalarFQ2(a.x, b),
            mulScalarFQ2(a.y, b),
            mulScalarFQ2(a.z, b)
        };
    }

    static function conjugateFQ12(FQ12 a) : FQ12 {
        return {
            negFQ6(a.x),
            a.y
        };
    }

    static function frobeniusFQ12(FQ12 a) : FQ12 {
        // Frobenius computes (xω+y)^p = x^p ω·ξ^((p-1)/6) + y^p
        return {
            mulScalarFQ6(frobeniusFQ6(a.x), xiToPMinus1Over6),
            frobeniusFQ6(a.y)
        };
    }

    static function frobeniusP2FQ12(FQ12 a) : FQ12 {
        // FrobeniusP2 computes (xω+y)^p² = x^p² ω·ξ^((p²-1)/6) + y^p²
        return {
            mulGFP(frobeniusP2FQ6(a.x), xiToPSquaredMinus1Over6),
            frobeniusP2FQ6(a.y)
        };
    }

    static function squareFQ12(FQ12 a): FQ12 {
        asm {
OP_7 OP_PICK OP_OVER OP_MUL OP_2 OP_PICK OP_8 OP_PICK OP_MUL OP_ADD OP_7 OP_PICK OP_2 OP_PICK OP_MUL OP_9 OP_PICK OP_4 OP_PICK OP_MUL OP_SUB OP_11 OP_PICK OP_5 OP_PICK OP_MUL OP_6 OP_PICK OP_12 OP_PICK OP_MUL OP_ADD OP_11 OP_PICK OP_6 OP_PICK OP_MUL OP_13 OP_PICK OP_8 OP_PICK OP_MUL OP_SUB OP_15 OP_PICK OP_9 OP_PICK OP_MUL OP_10 OP_PICK OP_16 OP_PICK OP_MUL OP_ADD OP_15 OP_PICK OP_10 OP_PICK OP_MUL 11 OP_PICK OP_12 OP_PICK OP_MUL OP_SUB 11 OP_PICK OP_16 OP_PICK OP_ADD 11 OP_PICK OP_16 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_5 OP_PICK OP_SUB OP_SWAP OP_4 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_SWAP OP_7 OP_PICK OP_ADD OP_SWAP OP_6 OP_PICK OP_ADD 11 OP_PICK OP_16 OP_PICK OP_ADD 11 OP_PICK OP_16 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_13 OP_PICK OP_12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_9 OP_PICK OP_SUB OP_SWAP OP_8 OP_PICK OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_5 OP_PICK OP_5 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD 15 OP_PICK 12 OP_PICK OP_ADD 15 OP_PICK 12 OP_PICK OP_ADD 11 OP_PICK OP_14 OP_PICK OP_ADD 11 OP_PICK OP_14 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_11 OP_ROLL OP_SUB OP_SWAP OP_10 OP_ROLL OP_SUB OP_SWAP OP_9 OP_ROLL OP_ADD OP_SWAP OP_8 OP_ROLL OP_ADD OP_SWAP OP_7 OP_ROLL OP_SUB OP_SWAP OP_6 OP_ROLL OP_SUB OP_15 OP_PICK OP_15 OP_PICK OP_15 OP_PICK OP_15 OP_PICK 15 OP_PICK 15 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB 11 OP_PICK OP_6 OP_ROLL OP_ADD OP_16 OP_PICK OP_6 OP_ROLL OP_ADD OP_15 OP_PICK OP_6 OP_ROLL OP_ADD OP_14 OP_PICK OP_6 OP_ROLL OP_ADD OP_13 OP_PICK OP_6 OP_ROLL OP_ADD OP_12 OP_PICK OP_6 OP_ROLL OP_ADD 17 OP_PICK 12 OP_PICK OP_ADD 17 OP_PICK 12 OP_PICK OP_ADD 17 OP_PICK 12 OP_PICK OP_ADD 17 OP_PICK 12 OP_PICK OP_ADD 17 OP_PICK 12 OP_PICK OP_ADD 17 OP_PICK 12 OP_PICK OP_ADD OP_OVER OP_7 OP_PICK OP_MUL OP_8 OP_PICK OP_2 OP_PICK OP_MUL OP_ADD OP_OVER OP_8 OP_PICK OP_MUL OP_3 OP_PICK OP_10 OP_PICK OP_MUL OP_SUB OP_5 OP_PICK OP_11 OP_PICK OP_MUL OP_12 OP_PICK OP_6 OP_PICK OP_MUL OP_ADD OP_5 OP_PICK OP_12 OP_PICK OP_MUL OP_7 OP_PICK OP_14 OP_PICK OP_MUL OP_SUB OP_9 OP_PICK OP_15 OP_PICK OP_MUL OP_16 OP_PICK OP_10 OP_PICK OP_MUL OP_ADD OP_9 OP_PICK OP_16 OP_PICK OP_MUL OP_11 OP_PICK 12 OP_PICK OP_MUL OP_SUB OP_11 OP_PICK OP_10 OP_PICK OP_ADD OP_11 OP_PICK OP_10 OP_PICK OP_ADD 13 OP_PICK 12 OP_PICK OP_ADD 13 OP_PICK 12 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_5 OP_PICK OP_SUB OP_SWAP OP_4 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_SWAP OP_7 OP_PICK OP_ADD OP_SWAP OP_6 OP_PICK OP_ADD OP_11 OP_ROLL OP_10 OP_PICK OP_ADD OP_11 OP_ROLL OP_10 OP_PICK OP_ADD 11 OP_ROLL OP_16 OP_PICK OP_ADD 11 OP_ROLL OP_16 OP_PICK OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_9 OP_PICK OP_SUB OP_SWAP OP_8 OP_PICK OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_5 OP_PICK OP_5 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD OP_13 OP_ROLL OP_12 OP_ROLL OP_ADD OP_12 OP_ROLL OP_12 OP_ROLL OP_ADD OP_15 OP_ROLL OP_14 OP_ROLL OP_ADD OP_14 OP_ROLL OP_14 OP_ROLL OP_ADD OP_SWAP OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_SWAP OP_11 OP_ROLL OP_SUB OP_SWAP OP_10 OP_ROLL OP_SUB OP_SWAP OP_9 OP_ROLL OP_ADD OP_SWAP OP_8 OP_ROLL OP_ADD OP_SWAP OP_7 OP_ROLL OP_SUB OP_SWAP OP_6 OP_ROLL OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_3 OP_ROLL OP_9 OP_PICK OP_SUB OP_3 OP_ROLL OP_8 OP_PICK OP_SUB OP_5 OP_ROLL OP_11 OP_PICK OP_SUB OP_5 OP_ROLL OP_10 OP_PICK OP_SUB OP_9 OP_PICK OP_9 OP_PICK OP_13 OP_PICK OP_13 OP_PICK OP_11 OP_PICK OP_11 OP_PICK OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_13 OP_ROLL OP_2 OP_MUL OP_13 OP_ROLL OP_2 OP_MUL OP_15 OP_ROLL OP_2 OP_MUL OP_15 OP_ROLL OP_2 OP_MUL 11 OP_ROLL OP_2 OP_MUL 11 OP_ROLL OP_2 OP_MUL 11 OP_ROLL OP_12 OP_ROLL OP_SUB OP_16 OP_ROLL OP_12 OP_ROLL OP_SUB OP_15 OP_ROLL OP_12 OP_ROLL OP_SUB OP_14 OP_ROLL OP_12 OP_ROLL OP_SUB OP_13 OP_ROLL OP_12 OP_ROLL OP_SUB OP_12 OP_ROLL OP_12 OP_ROLL OP_SUB
        }
    }

    static function OLDsquareFQ12(FQ12 a) : FQ12 {
        // Complex squaring algorithm
        FQ6 v0 = mulFQ6(a.x, a.y);

        FQ6 t = mulTauFQ6(a.x);
        FQ6 t2 = addFQ6(a.y, t);
        FQ6 ty = addFQ6(a.x, a.y);
        FQ6 ty2 = mulFQ6(ty, t2);
        FQ6 ty3 = subFQ6(ty2, v0);
        FQ6 t3 = mulTauFQ6(v0);

        FQ6 ty4 = subFQ6(ty3, t3);

        return {
            doubleFQ6(v0),
            ty4
        };
    }

    static function expFQ12_u(FQ12 a) : FQ12 {
        // u is the BN parameter that determines the prime.
        // u = 4965661367192848881;

        FQ12 sum = FQ12One;

        // Unrolled loop. Reference impl.:
        // https://github.com/ethereum/go-ethereum/blob/bd6879ac518431174a490ba42f7e6e822dcb3ee1/crypto/bn256/google/gfp12.go#L138
        FQ12 sum0 = squareFQ12(sum);
        sum0 = BN256.modFQ12(sum0);
        FQ12 sum1 = mulFQ12(sum0, a);
        FQ12 sum2 = squareFQ12(sum1);
        FQ12 sum3 = squareFQ12(sum2);
        FQ12 sum4 = squareFQ12(sum3);
        FQ12 sum5 = squareFQ12(sum4);
        FQ12 sum6 = mulFQ12(sum5, a);
        FQ12 sum7 = squareFQ12(sum6);
        FQ12 sum8 = squareFQ12(sum7);
        FQ12 sum9 = squareFQ12(sum8);
        FQ12 sum10 = mulFQ12(sum9, a);
        sum10 = BN256.modFQ12(sum10);
        FQ12 sum11 = squareFQ12(sum10);
        FQ12 sum12 = mulFQ12(sum11, a);
        FQ12 sum13 = squareFQ12(sum12);
        FQ12 sum14 = mulFQ12(sum13, a);
        FQ12 sum15 = squareFQ12(sum14);
        FQ12 sum16 = squareFQ12(sum15);
        FQ12 sum17 = mulFQ12(sum16, a);
        FQ12 sum18 = squareFQ12(sum17);
        FQ12 sum19 = squareFQ12(sum18);
        FQ12 sum20 = squareFQ12(sum19);
        sum20 = BN256.modFQ12(sum20);
        FQ12 sum21 = mulFQ12(sum20, a);
        FQ12 sum22 = squareFQ12(sum21);
        FQ12 sum23 = mulFQ12(sum22, a);
        FQ12 sum24 = squareFQ12(sum23);
        FQ12 sum25 = squareFQ12(sum24);
        FQ12 sum26 = squareFQ12(sum25);
        FQ12 sum27 = mulFQ12(sum26, a);
        FQ12 sum28 = squareFQ12(sum27);
        FQ12 sum29 = squareFQ12(sum28);
        FQ12 sum30 = squareFQ12(sum29);
        sum30 = BN256.modFQ12(sum30);
        FQ12 sum31 = mulFQ12(sum30, a);
        FQ12 sum32 = squareFQ12(sum31);
        FQ12 sum33 = squareFQ12(sum32);
        FQ12 sum34 = mulFQ12(sum33, a);
        FQ12 sum35 = squareFQ12(sum34);
        FQ12 sum36 = squareFQ12(sum35);
        FQ12 sum37 = mulFQ12(sum36, a);
        FQ12 sum38 = squareFQ12(sum37);
        FQ12 sum39 = mulFQ12(sum38, a);
        FQ12 sum40 = squareFQ12(sum39);
        sum40 = BN256.modFQ12(sum40);
        FQ12 sum41 = squareFQ12(sum40);
        FQ12 sum42 = mulFQ12(sum41, a);
        FQ12 sum43 = squareFQ12(sum42);
        FQ12 sum44 = squareFQ12(sum43);
        FQ12 sum45 = squareFQ12(sum44);
        FQ12 sum46 = squareFQ12(sum45);
        FQ12 sum47 = mulFQ12(sum46, a);
        FQ12 sum48 = squareFQ12(sum47);
        FQ12 sum49 = squareFQ12(sum48);
        FQ12 sum50 = squareFQ12(sum49);
        sum50 = BN256.modFQ12(sum50);
        FQ12 sum51 = mulFQ12(sum50, a);
        FQ12 sum52 = squareFQ12(sum51);
        FQ12 sum53 = squareFQ12(sum52);
        FQ12 sum54 = mulFQ12(sum53, a);
        FQ12 sum55 = squareFQ12(sum54);
        FQ12 sum56 = squareFQ12(sum55);
        FQ12 sum57 = squareFQ12(sum56);
        FQ12 sum58 = mulFQ12(sum57, a);
        FQ12 sum59 = squareFQ12(sum58);
        FQ12 sum60 = mulFQ12(sum59, a);
        sum60 = BN256.modFQ12(sum60);
        FQ12 sum61 = squareFQ12(sum60);
        FQ12 sum62 = squareFQ12(sum61);
        FQ12 sum63 = mulFQ12(sum62, a);
        FQ12 sum64 = squareFQ12(sum63);
        FQ12 sum65 = squareFQ12(sum64);
        FQ12 sum66 = squareFQ12(sum65);
        FQ12 sum67 = mulFQ12(sum66, a);
        FQ12 sum68 = squareFQ12(sum67);
        FQ12 sum69 = squareFQ12(sum68);
        FQ12 sum70 = squareFQ12(sum69);
        sum70 = BN256.modFQ12(sum70);
        FQ12 sum71 = squareFQ12(sum70);
        FQ12 sum72 = squareFQ12(sum71);
        FQ12 sum73 = mulFQ12(sum72, a);
        FQ12 sum74 = squareFQ12(sum73);
        FQ12 sum75 = squareFQ12(sum74);
        FQ12 sum76 = squareFQ12(sum75);
        FQ12 sum77 = mulFQ12(sum76, a);
        FQ12 sum78 = squareFQ12(sum77);
        FQ12 sum79 = mulFQ12(sum78, a);
        FQ12 sum80 = squareFQ12(sum79);
        sum80 = BN256.modFQ12(sum80);
        FQ12 sum81 = mulFQ12(sum80, a);
        FQ12 sum82 = squareFQ12(sum81);
        FQ12 sum83 = mulFQ12(sum82, a);
        FQ12 sum84 = squareFQ12(sum83);
        FQ12 sum85 = mulFQ12(sum84, a);
        FQ12 sum86 = squareFQ12(sum85);
        FQ12 sum87 = squareFQ12(sum86);
        FQ12 sum88 = squareFQ12(sum87);
        FQ12 sum89 = squareFQ12(sum88);
        FQ12 sum90 = mulFQ12(sum89, a);
        sum90 = BN256.modFQ12(sum90);
        
        return sum90;

    }

    static function expFQ12(FQ12 a, int power) : FQ12 {
        FQ12 sum = FQ12One;
        FQ12 t = FQ12One;

        bytes mb = reverseBytes(num2bin(power, S), S);
        bool firstOne = false;

        loop (CURVE_BITS_P8) : i {
            if (firstOne) {
                t = squareFQ12(sum);
            }

            if ((mb & (mask << ((CURVE_BITS_P8 - 1) - i))) != zero) {
                firstOne = true;
                sum = mulFQ12(t, a);
            } else {
                sum = t;
            }
        }

        return sum;
    }

    // ----------------------------------------------------

    static function doubleG1Point(G1Point a) : G1Point {
        CurvePoint res = doubleCurvePoint(
                createCurvePoint(a)
        );
        
        return getG1Point(res);
    }

    static function doubleCurvePoint(CurvePoint a): CurvePoint {
        asm {
OP_3 OP_PICK OP_4 OP_PICK OP_MUL OP_3 OP_PICK OP_4 OP_PICK OP_MUL OP_DUP OP_OVER OP_MUL OP_6 OP_PICK OP_ROT OP_ADD OP_DUP OP_OVER OP_MUL OP_NIP OP_DUP OP_3 OP_PICK OP_SUB OP_NIP OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_OVER OP_MUL OP_ROT OP_DROP OP_2 OP_4 OP_PICK OP_MUL OP_DUP OP_5 OP_ROLL OP_ADD OP_DUP OP_OVER OP_MUL OP_ROT OP_DROP OP_2 OP_3 OP_PICK OP_MUL OP_SWAP OP_OVER OP_SUB OP_NIP OP_2 OP_5 OP_ROLL OP_MUL OP_4 OP_ROLL OP_DROP OP_2 OP_OVER OP_MUL OP_NIP OP_2 OP_OVER OP_MUL OP_4 OP_ROLL OP_3 OP_PICK OP_SUB OP_ROT OP_DROP OP_3 OP_ROLL OP_OVER OP_MUL OP_NIP OP_SWAP OP_SUB OP_4 OP_PICK OP_4 OP_PICK OP_MUL OP_2 OP_MUL OP_0
        }
    }

    static function OLDdoubleCurvePoint(CurvePoint a) : CurvePoint {
        // See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/doubling/dbl-2009-l.op3
        CurvePoint res = {0, 0, 0, 0};

        int A = modReduce(a.x * a.x, P);
        int B = modReduce(a.y * a.y, P);
        int C = modReduce(B * B, P);

        int t = a.x + B;
        int t2 = modReduce(t * t, P);
        t = t2 - A;
        t2 = t - C;

        int d = t2 * 2;
        t = A * 2;
        int e = t + A;
        int f = modReduce(e * e, P);

        t = d * 2;
        res.x = f - t;

        t = C * 2;
        t2 = t * 2;
        t = t2 * 2;
        res.y = d - res.x;
        t2 = modReduce(e * res.y, P);
        res.y = t2 - t;

        //int prod = res.y * a.z;
        //if (a.t != 0) {
        //    prod = a.y * a.z;
        //}
        //res.z = modReduce(prod, P) * 2;

        int prod = a.y * a.z;
        res.z = modReduce(prod, P) * 2;

        return res;
    }

    static function addG1Points(G1Point a, G1Point b) : G1Point {
        CurvePoint res = addCurvePoints(
                BN256.P,
                createCurvePoint(a),
                createCurvePoint(b)
        );
        
        return getG1Point(res);
    }

    static function addCurvePoints(int P, CurvePoint a, CurvePoint b) : CurvePoint {
        asm {
OP_5 OP_ROLL OP_8 OP_PICK OP_MOD OP_ROT OP_8 OP_PICK OP_MOD OP_OVER OP_2 OP_PICK OP_MUL OP_OVER OP_2 OP_PICK OP_MUL OP_9 OP_PICK OP_OVER OP_MUL OP_7 OP_PICK OP_3 OP_PICK OP_MUL OP_4 OP_PICK OP_3 OP_PICK OP_MUL OP_11 OP_PICK OP_OVER OP_MUL OP_NIP OP_6 OP_PICK OP_5 OP_PICK OP_MUL OP_9 OP_PICK OP_OVER OP_MUL OP_3 OP_ROLL OP_4 OP_PICK OP_SUB OP_0 OP_OVER 11 OP_PICK OP_MOD OP_EQUAL OP_3 OP_ROLL OP_DROP OP_2 OP_2 OP_PICK OP_MUL OP_DUP OP_OVER OP_MUL OP_3 OP_PICK OP_OVER OP_MUL OP_ROT OP_DROP OP_4 OP_ROLL OP_5 OP_PICK OP_SUB OP_0 OP_OVER 13 OP_PICK OP_MOD OP_EQUAL OP_4 OP_ROLL OP_SWAP OP_BOOLAND OP_OVER OP_2 OP_PICK OP_ADD OP_7 OP_ROLL OP_5 OP_ROLL OP_MUL OP_OVER OP_2 OP_PICK OP_MUL OP_DUP OP_6 OP_PICK OP_SUB OP_5 OP_ROLL OP_DROP OP_2 OP_3 OP_PICK OP_MUL OP_2DUP OP_SUB OP_NIP OP_3 OP_ROLL OP_OVER OP_SUB OP_3 OP_ROLL OP_DROP OP_7 OP_ROLL OP_6 OP_ROLL OP_MUL OP_3 OP_ROLL OP_DROP OP_2 OP_OVER OP_MUL OP_NIP OP_3 OP_ROLL OP_2 OP_PICK OP_MUL OP_DUP OP_ROT OP_SUB OP_ROT OP_DROP OP_8 OP_PICK OP_8 OP_PICK OP_ADD OP_ROT OP_DROP OP_DUP OP_OVER OP_MUL OP_NIP OP_DUP OP_7 OP_ROLL OP_SUB OP_NIP OP_5 OP_ROLL OP_SUB OP_4 OP_ROLL OP_MUL OP_0 OP_6 OP_PICK OP_0 OP_EQUAL OP_IF OP_NIP OP_2DROP OP_DROP OP_5 OP_PICK OP_5 OP_PICK OP_3 OP_PICK OP_6 OP_PICK OP_ENDIF OP_6 OP_PICK OP_0 OP_EQUAL OP_NOT OP_6 OP_PICK OP_0 OP_EQUAL OP_BOOLAND OP_IF OP_NIP OP_2DROP OP_DROP OP_8 OP_PICK OP_8 OP_PICK OP_4 OP_PICK OP_9 OP_PICK OP_ENDIF OP_6 OP_PICK OP_0 OP_EQUAL OP_NOT OP_6 OP_PICK OP_0 OP_EQUAL OP_NOT OP_BOOLAND OP_5 OP_PICK OP_BOOLAND OP_IF OP_NIP OP_2DROP OP_DROP OP_8 OP_PICK OP_8 OP_PICK OP_4 OP_PICK OP_9 OP_PICK OP_3 OP_PICK OP_4 OP_PICK OP_MUL OP_3 OP_PICK OP_4 OP_PICK OP_MUL OP_DUP OP_OVER OP_MUL OP_6 OP_PICK OP_ROT OP_ADD OP_DUP OP_OVER OP_MUL OP_NIP OP_DUP OP_3 OP_PICK OP_SUB OP_NIP OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_OVER OP_MUL OP_ROT OP_DROP OP_2 OP_4 OP_PICK OP_MUL OP_DUP OP_5 OP_ROLL OP_ADD OP_DUP OP_OVER OP_MUL OP_ROT OP_DROP OP_2 OP_3 OP_PICK OP_MUL OP_SWAP OP_OVER OP_SUB OP_NIP OP_2 OP_5 OP_ROLL OP_MUL OP_4 OP_ROLL OP_DROP OP_2 OP_OVER OP_MUL OP_NIP OP_2 OP_OVER OP_MUL OP_4 OP_ROLL OP_3 OP_PICK OP_SUB OP_ROT OP_DROP OP_3 OP_ROLL OP_OVER OP_MUL OP_NIP OP_SWAP OP_SUB OP_4 OP_PICK OP_4 OP_PICK OP_MUL OP_2 OP_MUL OP_0 OP_7 OP_ROLL OP_DROP OP_6 OP_ROLL OP_DROP OP_5 OP_ROLL OP_DROP OP_4 OP_ROLL OP_DROP OP_ENDIF OP_4 OP_ROLL OP_DROP
        }
    }

    static function OLDaddCurvePoints(CurvePoint a, CurvePoint b) : CurvePoint {
        // See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3
        CurvePoint res = {0, 0, 0, 0};
        
        if (a.z == 0) {
            res = b;
        } else if (b.z == 0) {
            res = a;
        } else {
            // Normalize the points by replacing a = [x1:y1:z1] and b = [x2:y2:z2]
            // by [u1:s1:z1·z2] and [u2:s2:z1·z2]
            // where u1 = x1·z2², s1 = y1·z2³ and u1 = x2·z1², s2 = y2·z1³
            
            int z12 = modReduce(a.z * a.z, P);
            int z22 = modReduce(b.z * b.z, P);
            
            int u1 = modReduce(a.x * z22, P);
            int u2 = modReduce(b.x * z12, P);

            int t = modReduce(b.z * z22, P);
            int s1 = modReduce(a.y * t, P);

            t = modReduce(a.z * z12, P);
            int s2 = modReduce(b.y * t, P);

            // Compute x = (2h)²(s²-u1-u2)
            // where s = (s2-s1)/(u2-u1) is the slope of the line through
            // (u1,s1) and (u2,s2). The extra factor 2h = 2(u2-u1) comes from the value of z below.
            // This is also:
            // 4(s2-s1)² - 4h²(u1+u2) = 4(s2-s1)² - 4h³ - 4h²(2u1)
            //                        = r² - j - 2v
            // with the notations below.

            int h = u2 - u1;
            bool xEqual = h == 0;

            t = h * 2;
            // i = 4h²
            int i = modReduce(t * t, P);
            // j = 4h³
            int j = modReduce(h * i, P);

            t = s2 - s1;
            bool yEqual = t == 0;

            if (xEqual && yEqual) {
                res = doubleCurvePoint(a);
            } else {
                int r = t + t;
                int v = modReduce(u1 * i, P);

                // t4 = 4(s2-s1)²
                int t4 = modReduce(r * r, P);
                int t6 = t4 - j;
                t = v * 2;

                res.x = t6 - t;

                // Set y = -(2h)³(s1 + s*(x/4h²-u1))
                // This is also
                // y = - 2·s1·j - (s2-s1)(2x - 2i·u1) = r(v-x) - 2·s1·j
                t = v - res.x;
                t4 = modReduce(s1 * j, P);
                t6 = t4 * 2;
                t4 = modReduce(r * t, P);
                res.y = t4 - t6;
                
                // Set z = 2(u2-u1)·z1·z2 = 2h·z1·z2
                t = a.z + b.z;
                t4 = modReduce(t * t, P);
                t = t4 - z12;
                t4 = t - z22;
                res.z = modReduce(t4 * h, P);
            }
        }

        return res;
    }

    static function mulG1Point(G1Point a, int m) : G1Point {
        CurvePoint res = mulCurvePoint(
                createCurvePoint(a),
                m
        );
        
        return getG1Point(res);
    }
        
    static function mulCurvePoint(CurvePoint a, int m) : CurvePoint {
        CurvePoint res = {0, 1, 0, 0};

        if (m != 0) {
            // Double and add method.
            // Lowest bit to highest.
            CurvePoint t =   {0, 0, 0, 0};
            CurvePoint sum = {0, 0, 0, 0};

            bytes mb = reverseBytes(num2bin(m, S), S);
            bool firstOne = false;

            loop (CURVE_BITS_P8_DIV12) : k {
                loop(3): j {
                    if (firstOne) {
                        t = doubleCurvePoint(sum);
                    }
                    if ((mb & (mask << ((CURVE_BITS_P8 - 1) - (3*k+j)))) != zero) {
                        firstOne = true;
                        sum = addCurvePoints(BN256.P, t, a);
                    } else {
                        sum = t;
                    }
                }
                sum = BN256.modCurvePoint(sum);
            }
            res = sum;
        }
        return res;
    }


    static function makeAffineCurvePoint(CurvePoint a) : CurvePoint {
        // MakeAffine converts a to affine form. If c is ∞, then it sets
        // a to 0 : 1 : 0.

        CurvePoint res = a;
        if (modReduce(a.z, P) != 1) {
            if (a.z == 0) {
                res = {0, 1, 0, 0};
            } else {
                FQ zInv = modInverseBranchlessP(a.z);
                FQ t = modReduce(a.y * zInv, P);
                FQ zInv2 = modReduce(zInv * zInv, P);
                FQ ay = modReduce(t * zInv2, P);
                FQ ax = modReduce(a.x * zInv2, P);
                
                res = {ax, ay, 1, 1};
            }
        }

        return res;
    }

    static function negCurvePoint(CurvePoint a) : CurvePoint {
        return {
            a.x,
            -a.y,
            a.z,
            0
        };
    }

    static function isInfCurvePoint(CurvePoint a) : bool {
        return a.z == 0;
    }

    static function createCurvePoint(G1Point ccp) : CurvePoint {
        return ccp == {0, 0} ? {0, 1, 0, 0} : {ccp.x, ccp.y, 1, 1};
    }

    static function getG1Point(CurvePoint cp) : G1Point {
        CurvePoint acp = makeAffineCurvePoint(cp);
        return acp == {0, 1, 0, 0} ? {0, 0} : {acp.x, acp.y};
    }

    // ----------------------------------------------------

    static function doubleG2Point(G2Point a) : G2Point {
        TwistPoint res = doubleTwistPoint(
                createTwistPoint(a)
        );
        
        return getG2Point(res);
    }

    static function doubleTwistPoint(TwistPoint a) : TwistPoint {
        // See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/doubling/dbl-2009-l.op3
        TwistPoint res = {FQ2Zero, FQ2Zero, FQ2Zero, FQ2Zero};

        FQ2 A = squareFQ2(a.x);
        FQ2 B = squareFQ2(a.y);
        FQ2 C = squareFQ2(B);

        FQ2 t = addFQ2(a.x, B);
        FQ2 t2 = squareFQ2(t);
        t = subFQ2(t2, A);
        t2 = subFQ2(t, C);

        FQ2 d = mulScalarFQ2(t2, 2);
        t = mulScalarFQ2(A, 2);
        FQ2 e = addFQ2(t, A);
        FQ2 f = squareFQ2(e);

        t = mulScalarFQ2(d, 2);
        res.x = subFQ2(f, t);

        t = mulScalarFQ2(C, 2);
        t2 = mulScalarFQ2(t, 2);
        t = mulScalarFQ2(t2, 2);
        res.y = subFQ2(d, res.x);
        t2 = mulFQ2(e, res.y);
        res.y = subFQ2(t2, t);

        res.z = mulScalarFQ2(mulFQ2(a.y, a.z), 2);

        return res;
    }

    static function addG2Points(G2Point a, G2Point b) : G2Point {
        TwistPoint res = addTwistPoints(
                createTwistPoint(a),
                createTwistPoint(b)
        );
        
        return getG2Point(res);
    }

    static function addTwistPoints(TwistPoint a, TwistPoint b) : TwistPoint {
        TwistPoint res = {FQ2Zero, FQ2Zero, FQ2Zero, a.t};
        
        if (a.z == FQ2Zero) {
            res = b;
        } else if (b.z == FQ2Zero) {
            res = a;
        } else {
            // See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3

            // Normalize the points by replacing a = [x1:y1:z1] and b = [x2:y2:z2]
            // by [u1:s1:z1·z2] and [u2:s2:z1·z2]
            // where u1 = x1·z2², s1 = y1·z2³ and u1 = x2·z1², s2 = y2·z1³
            
            FQ2 z12 = squareFQ2(a.z);
            FQ2 z22 = squareFQ2(b.z);
            
            FQ2 u1 = mulFQ2(a.x, z22);
            FQ2 u2 = mulFQ2(b.x, z12);

            FQ2 t = mulFQ2(b.z, z22);
            FQ2 s1 = mulFQ2(a.y, t);

            t = mulFQ2(a.z, z12);
            FQ2 s2 = mulFQ2(b.y, t);

            // Compute x = (2h)²(s²-u1-u2)
            // where s = (s2-s1)/(u2-u1) is the slope of the line through
            // (u1,s1) and (u2,s2). The extra factor 2h = 2(u2-u1) comes from the value of z below.
            // This is also:
            // 4(s2-s1)² - 4h²(u1+u2) = 4(s2-s1)² - 4h³ - 4h²(2u1)
            //                        = r² - j - 2v
            // with the notations below.

            FQ2 h = subFQ2(u2, u1);
            bool xEqual = h == FQ2Zero;

            t = mulScalarFQ2(h, 2);
            // i = 4h²
            FQ2 i = squareFQ2(t);
            // j = 4h³
            FQ2 j = mulFQ2(h, i);

            t = subFQ2(s2, s1);
            bool yEqual = t == FQ2Zero;
            if (xEqual && yEqual) {
                res = doubleTwistPoint(a);
            } else {
                FQ2 r = mulScalarFQ2(t, 2);
                FQ2 v = mulFQ2(u1, i);

                // t4 = 4(s2-s1)²
                FQ2 t4 = squareFQ2(r);
                FQ2 t6 = subFQ2(t4, j);
                t = mulScalarFQ2(v, 2);

                res.x = subFQ2(t6, t);

                // Set y = -(2h)³(s1 + s*(x/4h²-u1))
                // This is also
                // y = - 2·s1·j - (s2-s1)(2x - 2i·u1) = r(v-x) - 2·s1·j
                t = subFQ2(v, res.x);
                t4 = mulFQ2(s1, j);
                t6 = mulScalarFQ2(t4, 2);
                t4 = mulFQ2(r, t);
                res.y = subFQ2(t4, t6);
                
                // Set z = 2(u2-u1)·z1·z2 = 2h·z1·z2
                t = addFQ2(a.z, b.z);
                t4 = squareFQ2(t);
                t = subFQ2(t4, z12);
                t4 = subFQ2(t, z22);
                res.z = mulFQ2(t4, h);
            }
        }

        return res;
    }

    static function makeAffineTwistPoint(TwistPoint a) : TwistPoint {
        TwistPoint res = a; 
        if (a.z != {0, 1}) {
            if (a.z == FQ2Zero) {
                res = {
                    FQ2Zero,
                    FQ2One,
                    FQ2Zero,
                    FQ2Zero
                };
            } else {
                FQ2 zInv = inverseFQ2(a.z);
                FQ2 t = mulFQ2(a.y, zInv);
                FQ2 zInv2 = squareFQ2(zInv);
                res.y = mulFQ2(t, zInv2);
                t = mulFQ2(a.x, zInv2);
                res.x = t;
                res.z = {0, 1};
                res.t = {0, 1};
            }
        }

        return res;
    }

    static function negTwistPoint(TwistPoint a) : TwistPoint {
        return {
            a.x,
            subFQ2(FQ2Zero, a.y),
            a.z,
            FQ2Zero
        };
    }

    static function isInfTwistPoint(TwistPoint a) : bool {
        return a.z == FQ2Zero;
    }

    static function createTwistPoint(G2Point ctp) : TwistPoint {
        // Output x and y coords from ZoKrates need to be swaped to work correctly.
        FQ2 x = {ctp.x.y, ctp.x.x};
        FQ2 y = {ctp.y.y, ctp.y.x};
        return ctp == {FQ2Zero, FQ2Zero} ? 
                      {FQ2Zero, FQ2One, FQ2Zero, FQ2Zero} : 
                      {x, y, FQ2One, FQ2One};
    }

    static function getG2Point(TwistPoint tp) : G2Point {
        TwistPoint atp = makeAffineTwistPoint(tp);
        return atp == {FQ2Zero, FQ2One, FQ2Zero, FQ2Zero} ?
                      {FQ2Zero, FQ2Zero} :
                      {atp.x, atp.y};
    }

}

"#;



let pairing_lib = r#"

struct LineFuncRes {
    FQ2 a;
    FQ2 b;
    FQ2 c;
    TwistPoint rOut;
}


library BN256Pairing {

    static function modLineFuncRes(LineFuncRes l): LineFuncRes {
        l.a = BN256.modFQ2(l.a);
        l.b = BN256.modFQ2(l.b);
        l.c = BN256.modFQ2(l.c);
        l.rOut.x = BN256.modFQ2(l.rOut.x);
        l.rOut.y = BN256.modFQ2(l.rOut.y);
        l.rOut.z = BN256.modFQ2(l.rOut.z);
        l.rOut.t = BN256.modFQ2(l.rOut.t);
        return l;
    }

    static function lineFuncAdd(TwistPoint r, TwistPoint p, CurvePoint q, FQ2 r2) : LineFuncRes {
        asm {
OP_13 OP_PICK OP_15 OP_PICK OP_MUL OP_16 OP_PICK OP_14 OP_PICK OP_MUL OP_ADD OP_13 OP_PICK OP_16 OP_PICK OP_MUL OP_15 OP_PICK 12 OP_PICK OP_MUL OP_SUB OP_13 OP_PICK 14 OP_PICK OP_ADD OP_13 OP_PICK 14 OP_PICK OP_ADD OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP OP_5 OP_PICK OP_SUB OP_SWAP OP_4 OP_PICK OP_SUB OP_SWAP 13 OP_PICK OP_SUB OP_SWAP 12 OP_PICK OP_SUB 12 OP_PICK 14 OP_PICK OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_3 OP_ROLL 19 OP_PICK OP_SUB OP_3 OP_ROLL 18 OP_PICK OP_SUB OP_2DUP OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_OVER OP_2 OP_PICK OP_ADD OP_OVER OP_2 OP_PICK OP_ADD OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_4 OP_PICK OP_OVER OP_3 OP_PICK OP_8 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_9 OP_ROLL 1d OP_PICK OP_SUB OP_9 OP_ROLL 1c OP_PICK OP_SUB OP_SWAP 1d OP_PICK OP_SUB OP_SWAP 1c OP_PICK OP_SUB 1e OP_PICK OP_5 OP_ROLL OP_6 OP_ROLL 20 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_3 OP_PICK OP_3 OP_PICK OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB 1d OP_PICK OP_12 OP_ROLL OP_ADD 1c OP_PICK OP_12 OP_ROLL OP_ADD OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP 1b OP_PICK OP_SUB OP_SWAP 1a OP_PICK OP_SUB OP_SWAP OP_11 OP_ROLL OP_SUB OP_SWAP OP_10 OP_ROLL OP_SUB OP_5 OP_ROLL OP_4 OP_PICK OP_SUB OP_5 OP_ROLL OP_4 OP_PICK OP_SUB OP_6 OP_PICK OP_8 OP_PICK OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB 1c OP_PICK OP_9 OP_ROLL OP_10 OP_ROLL 1e OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_3 OP_ROLL OP_ROT OP_SUB OP_ROT OP_ROT OP_SUB OP_3 OP_PICK OP_3 OP_PICK OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL 15 OP_PICK OP_6 OP_PICK OP_ADD 15 OP_PICK OP_6 OP_PICK OP_ADD OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP OP_13 OP_PICK OP_SUB OP_SWAP OP_12 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_11 OP_PICK 19 OP_PICK OP_MUL 1a OP_PICK OP_12 OP_PICK OP_MUL OP_ADD OP_11 OP_PICK 1a OP_PICK OP_MUL OP_13 OP_PICK 1c OP_PICK OP_MUL OP_SUB OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_SWAP OP_3 OP_ROLL OP_SUB OP_SWAP OP_ROT OP_SUB OP_7 OP_PICK 11 OP_PICK OP_MUL OP_7 OP_PICK 12 OP_PICK OP_MUL OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_0 OP_14 OP_ROLL OP_SUB OP_0 OP_14 OP_ROLL OP_SUB OP_SWAP 13 OP_PICK OP_MUL OP_SWAP 13 OP_PICK OP_MUL OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_5 OP_ROLL OP_5 OP_ROLL OP_3 OP_ROLL OP_3 OP_ROLL OP_5 OP_ROLL OP_5 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL OP_11 OP_ROLL OP_11 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL
        }
    }

    static function OLDlineFuncAdd(TwistPoint r, TwistPoint p, CurvePoint q, FQ2 r2) : LineFuncRes {
        // See the mixed addition algorithm from "Faster Computation of the
        // Tate Pairing", http://arxiv.org/pdf/0904.0854v3.pdf

        FQ2 B = BN256.mulFQ2(p.x, r.t);
        FQ2 D = BN256.addFQ2(p.y, r.z);
        D = BN256.squareFQ2(D);
        D = BN256.subFQ2(D, r2);
        D = BN256.subFQ2(D, r.t);
        D = BN256.mulFQ2(D, r.t);

        FQ2 H = BN256.subFQ2(B, r.x);
        FQ2 I = BN256.squareFQ2(H);

        FQ2 E = BN256.addFQ2(I, I);
        E = BN256.addFQ2(E, E);

        FQ2 J = BN256.mulFQ2(H, E);

        FQ2 L1 = BN256.subFQ2(D, r.y);
        L1 = BN256.subFQ2(L1, r.y);

        FQ2 V = BN256.mulFQ2(r.x, E);

        FQ2 rOutX = BN256.squareFQ2(L1);
        rOutX = BN256.subFQ2(rOutX, J);
        rOutX = BN256.subFQ2(rOutX, V);
        rOutX = BN256.subFQ2(rOutX, V);

        FQ2 rOutZ = BN256.addFQ2(r.z, H);
        rOutZ = BN256.squareFQ2(rOutZ);
        rOutZ = BN256.subFQ2(rOutZ, r.t);
        rOutZ = BN256.subFQ2(rOutZ, I);

        FQ2 t = BN256.subFQ2(V, rOutX);
        t = BN256.mulFQ2(t, L1);
        FQ2 t2 = BN256.mulFQ2(r.y, J);
        t2 = BN256.addFQ2(t2, t2);
        FQ2 rOutY = BN256.subFQ2(t, t2);

        FQ2 rOutT = BN256.squareFQ2(rOutZ);

        t = BN256.addFQ2(p.y, rOutZ);
        t = BN256.squareFQ2(t);
        t = BN256.subFQ2(t, r2);
        t = BN256.subFQ2(t, rOutT);

        t2 = BN256.mulFQ2(L1, p.x);
        t2 = BN256.addFQ2(t2, t2);
        FQ2 a = BN256.subFQ2(t2, t);

        FQ2 c = BN256.mulScalarFQ2(rOutZ, q.y);
        c = BN256.addFQ2(c, c);

        FQ2 b = BN256.subFQ2(BN256.FQ2Zero, L1);
        b = BN256.mulScalarFQ2(b, q.x);
        b = BN256.addFQ2(b, b);

        TwistPoint rOut = {
            rOutX, rOutY, rOutZ, rOutT
        };

        return {a, b, c, rOut};
    }

    static function lineFuncDouble(TwistPoint r, CurvePoint q) : LineFuncRes {
        asm {
OP_11 OP_PICK OP_11 OP_PICK OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_11 OP_PICK OP_11 OP_PICK OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_2DUP OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL 11 OP_PICK OP_4 OP_PICK OP_ADD 11 OP_PICK OP_4 OP_PICK OP_ADD OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB OP_SWAP OP_3 OP_PICK OP_SUB OP_SWAP OP_2 OP_PICK OP_SUB OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_7 OP_PICK OP_8 OP_PICK OP_ADD OP_7 OP_PICK OP_8 OP_PICK OP_ADD OP_SWAP OP_9 OP_PICK OP_ADD OP_SWAP OP_8 OP_PICK OP_ADD OP_2DUP OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_OVER OP_6 OP_PICK OP_SUB OP_OVER OP_6 OP_PICK OP_SUB OP_SWAP OP_7 OP_PICK OP_SUB OP_SWAP OP_6 OP_PICK OP_SUB 17 OP_PICK 16 OP_PICK OP_ADD 17 OP_PICK 16 OP_PICK OP_ADD OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP OP_13 OP_PICK OP_SUB OP_SWAP OP_12 OP_PICK OP_SUB OP_SWAP 15 OP_PICK OP_SUB OP_SWAP 14 OP_PICK OP_SUB OP_9 OP_ROLL OP_4 OP_PICK OP_SUB OP_9 OP_ROLL OP_4 OP_PICK OP_SUB OP_8 OP_PICK OP_10 OP_PICK OP_3 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_11 OP_PICK OP_12 OP_ROLL OP_ADD OP_11 OP_PICK OP_12 OP_ROLL OP_ADD OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_3 OP_ROLL OP_ROT OP_SUB OP_ROT OP_ROT OP_SUB OP_3 OP_PICK OP_3 OP_PICK OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_10 OP_PICK 15 OP_PICK 17 OP_PICK OP_14 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_0 OP_ROT OP_SUB OP_0 OP_ROT OP_SUB OP_SWAP 15 OP_PICK OP_MUL OP_SWAP 15 OP_PICK OP_MUL 1d OP_PICK OP_14 OP_ROLL OP_ADD 1c OP_PICK OP_14 OP_ROLL OP_ADD OP_DUP OP_2 OP_PICK OP_SUB OP_2 OP_PICK OP_2 OP_PICK OP_ADD OP_2 OP_4 OP_ROLL OP_4 OP_ROLL OP_MUL OP_MUL OP_SWAP OP_ROT OP_MUL OP_SWAP 11 OP_ROLL OP_SUB OP_SWAP OP_16 OP_ROLL OP_SUB OP_SWAP OP_13 OP_ROLL OP_SUB OP_SWAP OP_12 OP_ROLL OP_SUB OP_13 OP_PICK OP_14 OP_ROLL OP_ADD OP_13 OP_PICK OP_14 OP_ROLL OP_ADD OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_3 OP_ROLL OP_ROT OP_SUB OP_ROT OP_ROT OP_SUB OP_9 OP_PICK 11 OP_PICK OP_MUL 12 OP_PICK OP_10 OP_PICK OP_MUL OP_ADD OP_9 OP_PICK 12 OP_PICK OP_MUL OP_11 OP_PICK 14 OP_PICK OP_MUL OP_SUB OP_OVER OP_ROT OP_ADD OP_OVER OP_ROT OP_ADD OP_SWAP OP_16 OP_PICK OP_MUL OP_SWAP OP_16 OP_PICK OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_5 OP_ROLL OP_5 OP_ROLL OP_5 OP_ROLL OP_5 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL OP_11 OP_ROLL OP_11 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL OP_13 OP_ROLL
        }
    }

    static function OLDlineFuncDouble(TwistPoint r, CurvePoint q) : LineFuncRes {
        // See the doubling algorithm for a=0 from "Faster Computation of the
        // Tate Pairing", http://arxiv.org/pdf/0904.0854v3.pdf

        FQ2 A = BN256.squareFQ2(r.x);
        FQ2 B = BN256.squareFQ2(r.y);
        FQ2 C = BN256.squareFQ2(B);

        FQ2 D = BN256.addFQ2(r.x, B);
        D = BN256.squareFQ2(D);
        D = BN256.subFQ2(D, A);
        D = BN256.subFQ2(D, C);
        D = BN256.addFQ2(D, D);

        FQ2 E = BN256.addFQ2(A, A);
        E = BN256.addFQ2(E, A);

        FQ2 G = BN256.squareFQ2(E);

        FQ2 rOutX = BN256.subFQ2(G, D);
        rOutX = BN256.subFQ2(rOutX, D);

        FQ2 rOutZ = BN256.addFQ2(r.y, r.z);
        rOutZ = BN256.squareFQ2(rOutZ);
        rOutZ = BN256.subFQ2(rOutZ, B);
        rOutZ = BN256.subFQ2(rOutZ, r.t);

        FQ2 rOutY = BN256.subFQ2(D, rOutX);
        rOutY = BN256.mulFQ2(rOutY, E);
        FQ2 t = BN256.addFQ2(C, C);
        t = BN256.addFQ2(t, t);
        t = BN256.addFQ2(t, t);
        rOutY = BN256.subFQ2(rOutY, t);

        FQ2 rOutT = BN256.squareFQ2(rOutZ);

        t = BN256.mulFQ2(E, r.t);
        t = BN256.addFQ2(t, t);
        FQ2 b = BN256.subFQ2(BN256.FQ2Zero, t);
        b = BN256.mulScalarFQ2(b, q.x);

        FQ2 a = BN256.addFQ2(r.x, E);
        a = BN256.squareFQ2(a);
        a = BN256.subFQ2(a, A);
        a = BN256.subFQ2(a, G);
        t = BN256.addFQ2(B, B);
        t = BN256.addFQ2(t, t);
        a = BN256.subFQ2(a, t);

        FQ2 c = BN256.mulFQ2(rOutZ, r.t);
        c = BN256.addFQ2(c, c);
        c = BN256.mulScalarFQ2(c, q.y);

        TwistPoint rOut = {
            rOutX, rOutY, rOutZ, rOutT
        };

        return {a, b, c, rOut};
    }

    static function mulLine(FQ12 ret, FQ2 a, FQ2 b, FQ2 c) : FQ12 {
        asm {
OP_3 OP_PICK 11 OP_PICK OP_MUL 12 OP_PICK OP_4 OP_PICK OP_MUL OP_ADD OP_3 OP_PICK 12 OP_PICK OP_MUL OP_5 OP_PICK 14 OP_PICK OP_MUL OP_SUB OP_7 OP_PICK 11 OP_PICK OP_MUL 12 OP_PICK OP_8 OP_PICK OP_MUL OP_ADD OP_7 OP_PICK 12 OP_PICK OP_MUL OP_9 OP_PICK 14 OP_PICK OP_MUL OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD OP_4 OP_PICK 11 OP_PICK 13 OP_PICK OP_8 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_9 OP_PICK 11 OP_PICK OP_MUL 12 OP_PICK OP_10 OP_PICK OP_MUL OP_ADD OP_9 OP_PICK 12 OP_PICK OP_MUL OP_11 OP_PICK 14 OP_PICK OP_MUL OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD OP_6 OP_PICK 11 OP_PICK 13 OP_PICK OP_10 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_10 OP_PICK 17 OP_PICK 19 OP_PICK OP_14 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD 11 OP_PICK OP_7 OP_PICK OP_MUL OP_8 OP_PICK 12 OP_PICK OP_MUL OP_ADD 11 OP_PICK OP_8 OP_PICK OP_MUL 13 OP_PICK OP_10 OP_PICK OP_MUL OP_SUB 11 OP_PICK OP_9 OP_PICK OP_MUL OP_10 OP_PICK 12 OP_PICK OP_MUL OP_ADD 11 OP_PICK OP_10 OP_PICK OP_MUL 13 OP_PICK OP_12 OP_PICK OP_MUL OP_SUB 11 OP_PICK OP_11 OP_PICK OP_MUL OP_12 OP_PICK 12 OP_PICK OP_MUL OP_ADD 11 OP_PICK OP_12 OP_PICK OP_MUL 13 OP_PICK OP_14 OP_PICK OP_MUL OP_SUB OP_15 OP_PICK OP_14 OP_PICK OP_ADD OP_15 OP_PICK OP_14 OP_PICK OP_ADD 1f OP_PICK 1a OP_PICK OP_ADD 1f OP_PICK 1a OP_PICK OP_ADD 1f OP_PICK 1a OP_PICK OP_ADD 1f OP_PICK 1a OP_PICK OP_ADD 1f OP_PICK 1a OP_PICK OP_ADD 1f OP_PICK 1a OP_PICK OP_ADD OP_7 OP_PICK OP_5 OP_PICK OP_MUL OP_6 OP_PICK OP_8 OP_PICK OP_MUL OP_ADD OP_7 OP_PICK OP_6 OP_PICK OP_MUL OP_9 OP_PICK OP_8 OP_PICK OP_MUL OP_SUB 1b OP_PICK OP_5 OP_PICK OP_MUL OP_6 OP_PICK 1c OP_PICK OP_MUL OP_ADD 1b OP_PICK OP_6 OP_PICK OP_MUL 1d OP_PICK OP_8 OP_PICK OP_MUL OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD OP_8 OP_PICK OP_5 OP_ROLL OP_6 OP_ROLL OP_10 OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB 1b OP_PICK OP_5 OP_PICK OP_MUL OP_6 OP_PICK 1c OP_PICK OP_MUL OP_ADD 1b OP_PICK OP_6 OP_PICK OP_MUL 1d OP_PICK OP_8 OP_PICK OP_MUL OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD OP_8 OP_ROLL OP_5 OP_ROLL OP_6 OP_ROLL OP_9 OP_ROLL OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB 18 OP_PICK OP_7 OP_ROLL OP_8 OP_ROLL 1a OP_PICK OP_DUP OP_3 OP_PICK OP_MUL OP_2 OP_PICK OP_5 OP_PICK OP_MUL OP_ADD OP_SWAP OP_ROT OP_MUL OP_3 OP_ROLL OP_3 OP_ROLL OP_MUL OP_SWAP OP_SUB OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB OP_3 OP_ROLL OP_ROT OP_ADD OP_ROT OP_ROT OP_ADD OP_5 OP_ROLL 11 OP_PICK OP_SUB OP_5 OP_ROLL OP_16 OP_PICK OP_SUB OP_5 OP_ROLL OP_15 OP_PICK OP_SUB OP_5 OP_ROLL OP_14 OP_PICK OP_SUB OP_5 OP_ROLL OP_13 OP_PICK OP_SUB OP_5 OP_ROLL OP_12 OP_PICK OP_SUB OP_5 OP_ROLL OP_11 OP_PICK OP_SUB OP_5 OP_ROLL OP_10 OP_PICK OP_SUB OP_5 OP_ROLL OP_9 OP_PICK OP_SUB OP_5 OP_ROLL OP_8 OP_PICK OP_SUB OP_5 OP_ROLL OP_7 OP_PICK OP_SUB OP_5 OP_ROLL OP_6 OP_PICK OP_SUB OP_15 OP_ROLL OP_15 OP_ROLL OP_15 OP_ROLL OP_15 OP_ROLL 11 OP_ROLL 11 OP_ROLL OP_OVER OP_9 OP_MUL OP_OVER OP_ADD OP_9 OP_ROT OP_MUL OP_ROT OP_SUB 11 OP_ROLL OP_6 OP_ROLL OP_ADD OP_16 OP_ROLL OP_6 OP_ROLL OP_ADD OP_15 OP_ROLL OP_6 OP_ROLL OP_ADD OP_14 OP_ROLL OP_6 OP_ROLL OP_ADD OP_13 OP_ROLL OP_6 OP_ROLL OP_ADD OP_12 OP_ROLL OP_6 OP_ROLL OP_ADD
        }
    }

    static function OLDmulLine(FQ12 ret, FQ2 a, FQ2 b, FQ2 c) : FQ12 {
        FQ6 a2 = {BN256.FQ2Zero, a, b};
        a2 = BN256.mulFQ6(a2, ret.x);
        FQ6 t3 = BN256.mulScalarFQ6(ret.y, c);

        FQ2 t = BN256.addFQ2(b, c);
        FQ6 t2 = {BN256.FQ2Zero, a, t};

        FQ6 resX = BN256.addFQ6(ret.x, ret.y);
        FQ6 resY = t3;

        resX = BN256.mulFQ6(resX, t2);
        resX = BN256.subFQ6(resX, a2);
        resX = BN256.subFQ6(resX, resY);
        a2 = BN256.mulTauFQ6(a2);
        resY = BN256.addFQ6(resY, a2);

        return {resX, resY};
    }

    static function miller(TwistPoint q, CurvePoint p) : FQ12 {
        FQ12 ret = BN256.FQ12One;

        TwistPoint aAffine = BN256.makeAffineTwistPoint(q);
        CurvePoint bAffine = BN256.makeAffineCurvePoint(p);

        TwistPoint minusA = BN256.negTwistPoint(aAffine);

        TwistPoint r = aAffine;

        FQ2 r2 = BN256.squareFQ2(aAffine.y);

        // sixuPlus2NAF is 6u+2 in non-adjacent form.
        // Unrolled loop to get rid of in-loop branching. Reference impl.:
        // https://github.com/ethereum/go-ethereum/blob/bd6879ac518431174a490ba42f7e6e822dcb3ee1/crypto/bn256/google/optate.go#L213
        // var sixuPlus2NAF = {}int8{0, 0, 0, 1, 0, 1, 0, -1, 0, 0, 1, -1, 0, 0, 1, 0,
        //                           0, 1, 1, 0, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, 1, 1,
        //                           1, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 1,
        //                           1, 0, 0, -1, 0, 0, 0, 1, 1, 0, -1, 0, 0, 1, 0, 1, 1}
        
        //---- 1
        LineFuncRes lfr = lineFuncDouble(r, bAffine);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- -1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, minusA, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 1
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        lfr = lineFuncAdd(r, aAffine, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;
        //---- 0
        r = BN256.modTwistPoint(r);
        ret = BN256.modFQ12(ret);
        lfr = lineFuncDouble(r, bAffine);
        ret = BN256.squareFQ12(ret);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        // In order to calculate Q1 we have to convert q from the sextic twist
        // to the full GF(p^12) group, apply the Frobenius there, and convert
        // back.
        //
        // The twist isomorphism is (x', y') -> (xω², yω³). If we consider just
        // x for a moment, then after applying the Frobenius, we have x̄ω^(2p)
        // where x̄ is the conjugate of x. If we are going to apply the inverse
        // isomorphism we need a value with a single coefficient of ω² so we
        // rewrite this as x̄ω^(2p-2)ω². ξ⁶ = ω and, due to the construction of
        // p, 2p-2 is a multiple of six. Therefore we can rewrite as
        // x̄ξ^((p-1)/3)ω² and applying the inverse isomorphism eliminates the
        // ω².
        //
        // A similar argument can be made for the y value.

        FQ2 q1x = BN256.conjugateFQ2(aAffine.x);
        q1x = BN256.mulFQ2(q1x, BN256.xiToPMinus1Over3);
        FQ2 q1y = BN256.conjugateFQ2(aAffine.y);
        q1y = BN256.mulFQ2(q1y, BN256.xiToPMinus1Over2);

        TwistPoint q1 = {
            q1x, q1y, {0, 1}, {0, 1}
        };

        // For Q2 we are applying the p² Frobenius. The two conjugations cancel
        // out and we are left only with the factors from the isomorphism. In
        // the case of x, we end up with a pure number which is why
        // xiToPSquaredMinus1Over3 is ∈ GF(p). With y we get a factor of -1. We
        // ignore this to end up with -Q2.

        FQ2 minusQ2x = BN256.mulScalarFQ2(aAffine.x, BN256.xiToPSquaredMinus1Over3);
        TwistPoint minusQ2 = {
            minusQ2x, aAffine.y, {0, 1}, {0, 1}
        };

        r2 = BN256.squareFQ2(q1.y);
        lfr = lineFuncAdd(r, q1, bAffine, r2);
        ret = mulLine(ret, lfr.a, lfr.b, lfr.c);
        r = lfr.rOut;

        r2 = BN256.squareFQ2(minusQ2.y);
        lfr = lineFuncAdd(r, minusQ2, bAffine, r2);
        return BN256.modFQ12(mulLine(ret, lfr.a, lfr.b, lfr.c));
    }

    static function finalExponentiation(FQ12 in) : FQ12 {
        FQ12 t1 = {
            BN256.negFQ6(in.x),
            in.y
        }; 

        FQ12 inv = BN256.inverseFQ12(in);
        t1 = BN256.mulFQ12(t1, inv);

        FQ12 t2 = BN256.frobeniusP2FQ12(t1);
        t1 = BN256.mulFQ12(t1, t2);

        FQ12 fp = BN256.frobeniusFQ12(t1);
        FQ12 fp2 = BN256.frobeniusP2FQ12(t1);
        FQ12 fp3 = BN256.frobeniusFQ12(fp2);
        fp = BN256.modFQ12(fp);
        fp2 = BN256.modFQ12(fp2);
        fp3 = BN256.modFQ12(fp3);

        FQ12 fu = BN256.expFQ12_u(t1);
        FQ12 fu2 = BN256.expFQ12_u(fu);
        FQ12 fu3 = BN256.expFQ12_u(fu2);

        FQ12 y3 = BN256.frobeniusFQ12(fu);
        FQ12 fu2p = BN256.frobeniusFQ12(fu2);
        FQ12 fu3p = BN256.frobeniusFQ12(fu3);
        FQ12 y2 = BN256.frobeniusP2FQ12(fu2);

        FQ12 y0 = BN256.mulFQ12(fp, fp2);
        y0 = BN256.mulFQ12(y0, fp3);

        FQ12 y1 = BN256.conjugateFQ12(t1);
        FQ12 y5 = BN256.conjugateFQ12(fu2);
        y3 = BN256.conjugateFQ12(y3);
        FQ12 y4 = BN256.mulFQ12(fu ,fu2p);
        y4 = BN256.conjugateFQ12(y4);

        FQ12 y6 = BN256.mulFQ12(fu3, fu3p);
        y6 = BN256.conjugateFQ12(y6);

        FQ12 t0 = BN256.squareFQ12(y6);
        t0 = BN256.modFQ12(t0);
        t0 = BN256.mulFQ12(t0, y4);
        t0 = BN256.mulFQ12(t0, y5);
        t1 = BN256.mulFQ12(y3, y5);
        t1 = BN256.mulFQ12(t1, t0);
        t0 = BN256.mulFQ12(t0, y2);
        t1 = BN256.squareFQ12(t1);
        t1 = BN256.mulFQ12(t1, t0);
        t1 = BN256.squareFQ12(t1);
        t0 = BN256.mulFQ12(t1, y1);
        t1 = BN256.mulFQ12(t1, y0);
        t0 = BN256.squareFQ12(t0);
        t0 = BN256.mulFQ12(t0, t1);
        t0 = BN256.modFQ12(t0);

        return t0;
    }

    static function pairInternal(CurvePoint g1, TwistPoint g2) : FQ12 {
        FQ12 e = miller(g2, g1);
        FQ12 ret = finalExponentiation(e);

        if (BN256.isInfTwistPoint(g2) || BN256.isInfCurvePoint(g1)) {
            ret = BN256.FQ12One;
        }

        return ret;
    }

    static function pair(G1Point g1, G2Point g2) : FQ12 {
        return pairInternal(
                BN256.createCurvePoint(g1), 
                BN256.createTwistPoint(g2)
            );
    }

    static function pairCheckP4PrecalcInternal(
            CurvePoint a0, TwistPoint b0,
            FQ12 millerBetaAlpha,
            CurvePoint a2, TwistPoint b2,
            CurvePoint a3, TwistPoint b3
            ) : bool {

        a0 = BN256.makeAffineCurvePoint(a0);
        a2 = BN256.makeAffineCurvePoint(a2);
        a3 = BN256.makeAffineCurvePoint(a3);
        
        FQ12 acc = millerBetaAlpha;

        if (!BN256.isInfCurvePoint(a0) && !BN256.isInfTwistPoint(b0)) {
            acc = BN256.mulFQ12(acc, miller(b0, a0));
        }
        acc = BN256.modFQ12(acc);
        if (!BN256.isInfCurvePoint(a2) && !BN256.isInfTwistPoint(b2)) {
            acc = BN256.mulFQ12(acc, miller(b2, a2));
        }
        acc = BN256.modFQ12(acc);
        if (!BN256.isInfCurvePoint(a3) && !BN256.isInfTwistPoint(b3)) {
            acc = BN256.mulFQ12(acc, miller(b3, a3));
        }
        acc = BN256.modFQ12(acc);

        acc = finalExponentiation(acc);
        acc = BN256.modFQ12(acc);

        return acc == BN256.FQ12One;
    }

    // Check four pairs.
    // A * B + inputs * (-gamma) + C * (-delta) == alpha * beta
    // where alpha * beta is precalculated.
    static function pairCheckP4Precalc(
            G1Point a0, G2Point b0,
            FQ12 millerBetaAlpha,
            G1Point a2, G2Point b2,
            G1Point a3, G2Point b3) : bool {
        return pairCheckP4PrecalcInternal(
                BN256.createCurvePoint(a0), BN256.createTwistPoint(b0),
                millerBetaAlpha,
                BN256.createCurvePoint(a2), BN256.createTwistPoint(b2),
                BN256.createCurvePoint(a3), BN256.createTwistPoint(b3)
            );
    }

    static function pairCheckP2PrecalcInternal(
            CurvePoint a0, TwistPoint b0,
            CurvePoint a1, TwistPoint b1) : bool {
        FQ12 acc = BN256.FQ12One;

        a0 = BN256.makeAffineCurvePoint(a0);
        a1 = BN256.makeAffineCurvePoint(a1);

        if (!BN256.isInfCurvePoint(a0) && !BN256.isInfTwistPoint(b0)) {
            acc = BN256.mulFQ12(acc, miller(b0, a0));
        }

        if (!BN256.isInfCurvePoint(a1) && !BN256.isInfTwistPoint(b1)) {
            acc = BN256.mulFQ12(acc, miller(b1, a1));
        }

        acc = finalExponentiation(acc);

        return acc == BN256.FQ12One;
    }

    static function pairCheckP2Precalc(
            G1Point a0, G2Point b0,
            G1Point a1, G2Point b1) : bool {
        return pairCheckP2PrecalcInternal(
                BN256.createCurvePoint(a0), BN256.createTwistPoint(b0),
                BN256.createCurvePoint(a1), BN256.createTwistPoint(b1)
            );
    }

}
 
"#;

    [
        bn256_lib,
        pairing_lib,
    ]
    .join("\n")
}

pub fn scrypt_pairing_lib_bls12_381() -> String {
    let bls12_381_lib = r#"
type fe   = int;
type fe2  = fe[2];
type fe6  = fe2[3];
type fe12 = fe6[2];

type fp2 = fe2[2];
// PointG1 is type for point in G1.
// PointG1 is both used for Affine and Jacobian point representation.
// If z is equal to one the point is considered as in affine form.
type PointG1 = fe[3];
// PointG2 is type for point in G2.
// PointG2 is both used for Affine and Jacobian point representation.
// If z is equal to one the point is considered as in affine form.
type PointG2 = fe2[3];

// G1 is struct for G1 group.
type G1 = fe[9];
// G2 is struct for G2 group.
type G2 = fe2[9];
// GT is type for target multiplicative group GT.
type GT = fe12;


library BLS12381 {
    //----------------Field Constants
    // Base field modulus
    static fe P = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab;

    // r mod p
    static const fe r1 = 0x15f65ec3fa80e4935c071a97a256ec6d77ce5853705257455f48985753c758baebf4000bc40c0002760900000002fffd;

    //Montgomery form
    static const int R1sft384 = 0x01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    static const int Minv_neg = 0x00ceb06106feaafc9468b316fee268cf5819ecca0e8eb2db4c16ef2ef0c8e30b48286adb92d9d113e889f3fffcfffcfffd;

    //----------------
    static const int S = 32;
    static const bytes mask = reverseBytes(num2bin(1, S), S);
    static const bytes zero = reverseBytes(num2bin(0, S), S);

    static const fe2 Fe2Zero = [0, 0];
    static const fe6 Fe6Zero = repeat(Fe2Zero, 3);
    static const fe12 Fe12Zero = [Fe6Zero, Fe6Zero];
    static const G1 G1Zero = repeat(0, 9);
    static const G2 G2Zero = repeat(Fe2Zero, 9);
    static const PointG1 PtG1Zero = [0, 0, 0];
    //static const PointG2 PtG2Zero = [0, 0, 0];
    static const fe2 [6]Fe2_6Zero = repeat(Fe2Zero, 6);

    //----------------Frobenious Coeffs
    static const fe2 [6]frobeniusCoeffs61 = [
        [r1, 0],
        [0, 0x18f020655463874103f97d6e83d050d28eb60ebe01bacb9e587042afd3851b955dab22461fcda5d2cd03c9e48671f071],
        [0x051ba4ab241b61603636b76660701c6ec26a2ff874fd029b16a8ca3ac61577f7f3b8ddab7ece5a2a30f1361b798a64e8, 0],
        [0, r1],
        [0x18f020655463874103f97d6e83d050d28eb60ebe01bacb9e587042afd3851b955dab22461fcda5d2cd03c9e48671f071, 0],
        [0, 0x051ba4ab241b61603636b76660701c6ec26a2ff874fd029b16a8ca3ac61577f7f3b8ddab7ece5a2a30f1361b798a64e8]
    ];

    static const fe2 [6]frobeniusCoeffs62 = [
        [r1, 0],
        [0x14e56d3f1564853a14e4f04fe2db9068a20d1b8c7e88102450880866309b7e2c2af322533285a5d5890dc9e4867545c3, 0],
        [0x18f020655463874103f97d6e83d050d28eb60ebe01bacb9e587042afd3851b955dab22461fcda5d2cd03c9e48671f071, 0],
        [0x040ab3263eff0206ef148d1ea0f4c069eca8f3318332bb7a07e83a49a2e99d6932b7fff2ed47fffd43f5fffffffcaaae, 0],
        [0x051ba4ab241b61603636b76660701c6ec26a2ff874fd029b16a8ca3ac61577f7f3b8ddab7ece5a2a30f1361b798a64e8, 0],
        [0x0110f184e51c5f5947222a47bf7b5c04d5c13cc6f1ca47210ec08ff1232bda8ec100ddb891865a2cecfb361b798dba3a, 0]
    ];

    static const fe2 [12]frobeniusCoeffs12 = [
        [r1, 0],
        [0x08f2220fb0fb66eb1ce393ea5daace4da35baecab2dc29ee97e83cccd117228fc6695f92b50a831307089552b319d465,
         0x110eefda88847faf2e3813cbe5a0de89c11b9cba40a8e8d0cf4895d42599d3945842a06bfc497cecb2f66aad4ce5d646],
        [0x0110f184e51c5f5947222a47bf7b5c04d5c13cc6f1ca47210ec08ff1232bda8ec100ddb891865a2cecfb361b798dba3a, 0],
        [0x0bd592fc7d825ec81d794e4fac7cf0b992ad2afd19103e18382844c88b6237324294213d86c181833e2f585da55c9ad1,
         0x0e2b7eedbbfd87d22da2596696cebc1dd1ca2087da74d4a72f088dd86b4ebef1dc17dec12a927e7c7bcfa7a25aa30fda],
        [0x051ba4ab241b61603636b76660701c6ec26a2ff874fd029b16a8ca3ac61577f7f3b8ddab7ece5a2a30f1361b798a64e8, 0],
        [0x02e370eccc86f7dd0095ba654ed2226bef517c3266341429a04007fbba4b14a27c2ac1aad1b6fe703726c30af242c66c,
         0x171da0fd6cf8eebd4a85ed50f4798a6b7525cf528d50fe95c6f0caa53c65e181a2813e53df9d018f82d83cf50dbce43f],
        [0x040ab3263eff0206ef148d1ea0f4c069eca8f3318332bb7a07e83a49a2e99d6932b7fff2ed47fffd43f5fffffffcaaae, 0],
        [0x110eefda88847faf2e3813cbe5a0de89c11b9cba40a8e8d0cf4895d42599d3945842a06bfc497cecb2f66aad4ce5d646,
         0x08f2220fb0fb66eb1ce393ea5daace4da35baecab2dc29ee97e83cccd117228fc6695f92b50a831307089552b319d465],
        [0x18f020655463874103f97d6e83d050d28eb60ebe01bacb9e587042afd3851b955dab22461fcda5d2cd03c9e48671f071, 0],
        [0x0e2b7eedbbfd87d22da2596696cebc1dd1ca2087da74d4a72f088dd86b4ebef1dc17dec12a927e7c7bcfa7a25aa30fda,
         0x0bd592fc7d825ec81d794e4fac7cf0b992ad2afd19103e18382844c88b6237324294213d86c181833e2f585da55c9ad1],
        [0x14e56d3f1564853a14e4f04fe2db9068a20d1b8c7e88102450880866309b7e2c2af322533285a5d5890dc9e4867545c3, 0],
        [0x171da0fd6cf8eebd4a85ed50f4798a6b7525cf528d50fe95c6f0caa53c65e181a2813e53df9d018f82d83cf50dbce43f,
         0x02e370eccc86f7dd0095ba654ed2226bef517c3266341429a04007fbba4b14a27c2ac1aad1b6fe703726c30af242c66c]
    ];

    //----------------
    // static const int UB = 768; 
    static const int UB = 548; 
    static function modInverseEGCD(int x, int n) : int {
        // The following script already does modular reduction at the start so there's no
        // need to normalize x before function call.
        asm {
            OP_2DUP OP_MOD OP_DUP OP_0 OP_LESSTHAN OP_IF OP_DUP OP_2 OP_PICK OP_ADD OP_ELSE OP_DUP OP_ENDIF OP_NIP OP_2 OP_ROLL OP_DROP
            OP_DUP OP_TOALTSTACK OP_TOALTSTACK OP_TOALTSTACK
            OP_1 OP_0 OP_1
            loop(UB) {
                OP_FROMALTSTACK OP_FROMALTSTACK OP_2DUP OP_DUP OP_IF OP_TUCK OP_MOD OP_TOALTSTACK OP_TOALTSTACK OP_DIV OP_MUL OP_SUB OP_TUCK OP_ELSE OP_TOALTSTACK OP_TOALTSTACK OP_DROP OP_DROP OP_ENDIF
            }
            OP_FROMALTSTACK OP_FROMALTSTACK OP_DROP OP_DROP OP_DROP OP_FROMALTSTACK OP_SWAP OP_NIP
        }
    }

    static function mod(fe a, fe modulus) : fe {
        const fe res = a % modulus;
        return res >= 0 ? res : modulus + res;
    }

    //--------------------- 

    static function oneFe2() : fe2 {
        return [r1, 0];
    }

    static function zeroFe2() : fe2 {
        return Fe2Zero;
    }

    static function isOneFe2(fe2 e2) : bool {
	    return e2[0] == r1 && e2[1] == 0;
    }

    static function isZeroFe2(fe2 e2) : bool {
	    return e2[0] == 0 && e2[1] == 0;
    }

    static function equalFe2(fe2 a, fe2 b) : bool {
        return a[0] == b[0] && a[1] == b[1];
    }

    static function isOneFe6(fe6 e) : bool {
	    return isOneFe2(e[0]) && isZeroFe2(e[1]) && isZeroFe2(e[2]);
    }

    static function isZeroFe6(fe6 e) : bool {
	    return isZeroFe2(e[0]) && isZeroFe2(e[1]) && isZeroFe2(e[2]);
    }

    static function zeroFe6() : fe6 {
        return [zeroFe2(), zeroFe2(), zeroFe2()];
    }

    static function oneFe6() : fe6 {
        return [oneFe2(), zeroFe2(), zeroFe2()];
    }

    static function oneFe12() : fe12 {
        return [oneFe6(), zeroFe6()];
    }

    static function isOneFe12(fe12 e) : bool {
	    return isOneFe6(e[0]) && isZeroFe6(e[1]);
    }


    //--------------------- 
    static function toMont(fe a) : fe {
        fe res = a << 384;
        res = res % P;
        return res;
    }

    static function fromMont(fe a) : fe {
        fe U = mod(a * Minv_neg, R1sft384);
        fe T = a + U * P >> 384;

        return mod(T, P);
    }

    static function mulFe(fe a, fe b) : fe {
        return fromMont(mod(a * b, P));
    }

    static function squareFe(fe a) : fe {
        return fromMont(mod(a * a, P));
    }

    static function inverse(fe e) : fe {
        // fe inv = 0;
        // if(e != 0) {
        //     fe u = P;
        //     fe v = e;
        //     fe s = 1;
        //     fe r = 0;
        //     int k = 0;
        //     int z = 0;
        //     bool found = false;

        // 	// Phase 1
        //     loop(768) : i {
        //         if(found == false) {
        //             if(v == 0) {
        //                 found = true;
        //             } else {
        //                 if(u % 2 == 0) {
        //                     u = u >> 1;
        //                     s = s << 1;
        //                 } else if(v % 2 == 0) {
        //                     v = v >> 1;
        //                     r = r << 1;
        //                     z = z + (r >> 383);
        //                 } else if(u > v) {
        //                     u = u - v;
        //                     u = u >> 1;
        //                     r = r + s;
        //                     s = s << 1;
        //                 } else {
        //                     v = v - u;
        //                     v = v >> 1;
        //                     s = s + r;
        //                     r = r << 1;
        //                     z = z + (r >> 383);
        //                 }
        //                 k = k + 1;
        //             }
        //         }
        //     }

        //     if(found == false) {
        //         inv = 0;
        //     } else {
        //         if(k < 381 || k > 381 + 384) {
        //             inv = 0;
        //         } else {
        //             if(r >= P || z > 0) {
        //                 r = r - P;
        //             }
        //             u = P;
        //             u = u - r;

        //             loop(768) : i {
        //                 if(i >= k) {
        //                     u = u << 1;
        //                 }
        //             }
        //             inv = mod(u, P);
        //         }
        //     }
        // }
        // return inv;

        return toMont(toMont(modInverseEGCD(e, P)));
    }

    //--------------------- 
    static function addFe2(fe2 a, fe2 b) : fe2 {
        return [mod(a[0] + b[0], P), mod(a[1] + b[1], P)];
    }

    static function doubleFe2(fe2 a) : fe2 {
        return [mod(a[0] + a[0], P), mod(a[1] + a[1], P)
        ];
    }

    static function subFe2(fe2 a, fe2 b) : fe2 {
        return [mod(a[0] - b[0], P), mod(a[1] - b[1], P)];
    }

    static function negFe2(fe2 a) : fe2 {
        return [mod(a[0] * -1, P), mod(a[1] * -1, P)];
    }

    static function mulFe2(fe2 a, fe2 b) : fe2 {
        fe [4]t = [0, 0, 0, 0];
        fe2 c = Fe2Zero;

        t[0] = mod(a[0] * b[1], P);
        t[1] = mod(b[0] * a[1], P);
        c[1] = fromMont(mod(t[0] + t[1], P));

        t[2] = mod(a[1] * b[1], P);
        t[3] = mod(a[0] * b[0], P);
        c[0] = fromMont(mod(t[3] - t[2], P));

        return c;
    }

    static function squareFe2(fe2 a) : fe2 {
        fe [4]t = [0, 0, 0, 0];
        fe2 c = Fe2Zero;

        t[0] = mod(a[0] + a[1], P);
        t[1] = mod(a[0] - a[1], P);
        t[2] = mod(a[0] + a[0], P);
        c[0] = fromMont(mod(t[0] * t[1], P));
        c[1] = fromMont(mod(t[2] * a[1], P));

        return c;
    }

   static function mulByNonResidueFe2(fe2 a) : fe2 {
        fe2 c = Fe2Zero;
        fe2 t = Fe2Zero;

        t[0] = mod(a[0] - a[1], P);
        c[1] = mod(a[0] + a[1], P);
        c[0] = t[0];
        return c;
    }

    static function inverseFe2(fe2 a) : fe2 {
        fe2 c = Fe2Zero;
        fe2 t = Fe2Zero;
        t[0] = mod(a[0] * a[0], P);
        t[1] = mod(a[1] * a[1], P);
        t[0] = mod(t[0] + t[1], P);
        t[0] = inverse(t[0]);
        c[0] = mod(a[0] * t[0], P);
        t[0] = mod(t[0] * a[1], P);
        c[1] = mod(t[0] *-1, P);
        return  c;
    }

    //--------------------- 
    static function addFe6(fe6 a, fe6 b) : fe6 {
        return [addFe2(a[0], b[0]), addFe2(a[1], b[1]), addFe2(a[2], b[2])];
    }

    static function doubleFe6(fe6 a) : fe6 {	
        return [doubleFe2(a[0]), doubleFe2(a[1]), doubleFe2(a[2])];	
    }	

    static function subFe6(fe6 a, fe6 b) : fe6 {	
        return [subFe2(a[0], b[0]),	subFe2(a[1], b[1]), subFe2(a[2], b[2])];	
    }	

    static function negFe6(fe6 a) : fe6 {
        return [negFe2(a[0]), negFe2(a[1]), negFe2(a[2])];
    }

    static function mulFe6(fe6 a, fe6 b) : fe6 {
        fe6 c = Fe6Zero;
        fe2 [6]t = Fe2_6Zero;

        t[0] = mulFe2(a[0], b[0]);
        t[1] = mulFe2(a[1], b[1]);
        t[2] = mulFe2(a[2], b[2]);
        t[3] = addFe2(a[1], a[2]);
        t[4] = addFe2(b[1], b[2]);        
        t[3] = mulFe2(t[3], t[4]);
        t[4] = addFe2(t[1], t[2]);  
        t[3] = subFe2(t[3], t[4]);
        t[3] = mulByNonResidueFe2(t[3]);
        t[5] = addFe2(t[0], t[3]);

        t[3] = addFe2(a[0], a[1]);
        t[4] = addFe2(b[0], b[1]);
        t[3] = mulFe2(t[3], t[4]);
        t[4] = addFe2(t[0], t[1]);
        t[3] = subFe2(t[3], t[4]);
        t[4] = mulByNonResidueFe2(t[2]);
        c[1] = addFe2(t[3], t[4]);

        t[3] = addFe2(a[0], a[2]);
        t[4] = addFe2(b[0], b[2]);
        t[3] = mulFe2(t[3], t[4]);
        t[4] = addFe2(t[0], t[2]);
        t[3] = subFe2(t[3], t[4]);
        c[2] = addFe2(t[1], t[3]);

        c[0] = t[5];

        return c;
    }

    static function mulByNonResidueFe6(fe6 a) : fe6 {
        fe6 c = Fe6Zero;

        c[0] = mulByNonResidueFe2(a[2]);
        c[2] = a[1];
        c[1] = a[0];

        return c;
    }

    static function mulFe12(fe12 a, fe12 b) : fe12 {
        fe12 c = Fe12Zero;
        fe6 [4]t = repeat(Fe6Zero, 4);

        t[1] = mulFe6(a[0], b[0]);
        t[2] = mulFe6(a[1], b[1]);
        t[0] = addFe6(t[1], t[2]);
        t[2] = mulByNonResidueFe6(t[2]);
        t[3] = addFe6(t[1], t[2]);
        t[1] = addFe6(a[0], a[1]);
        t[2] = addFe6(b[0], b[1]);
        t[1] = mulFe6(t[1], t[2]);

        c[0] = t[3];
        c[1] = subFe6(t[1], t[0]);

        return c;
    }

    static function conjugateFe12(fe12 a) : fe12 {
        fe12 c = Fe12Zero;

        c[0] = a[0];
        c[1] = negFe6(a[1]);
        return c;
    }


    //--------------------- for millerLoop()
    static function mulByFqFe2(fe2 a, fe b) : fe2 {
        fe2 c = Fe2Zero;
        c[0] = fromMont(mod(a[0] * b, P));
        c[1] = fromMont(mod(a[1] * b, P));
        return  c;
    }

   static function mulByBFe2(fe2 a) : fe2 {
        fe2 c = Fe2Zero;
        fe2 t = Fe2Zero;

        t[0] = mod(a[0] + a[0], P);
        t[1] = mod(a[1] + a[1], P);
        t[0] = mod(t[0] + t[0], P);
        t[1] = mod(t[1] + t[1], P);
        c[0] = mod(t[0] - t[1], P);
        c[1] = mod(t[0] + t[1], P);
        return c;
   }

    static function mulBy01Fe6(fe6 a, fe2 b0, fe2 b1) : fe6 {
        fe6 c = Fe6Zero;
        fe2 [6]t = Fe2_6Zero;

        t[0] = mulFe2(a[0], b0);
        t[1] = mulFe2(a[1], b1);
        t[2] = addFe2(a[1], a[2]);
        t[2] = mulFe2(t[2], b1);
        t[2] = subFe2(t[2], t[1]);
        t[2] = mulByNonResidueFe2(t[2]);
        t[3] = addFe2(a[0], a[2]);
        t[3] = mulFe2(t[3], b0);
        t[3] = subFe2(t[3], t[0]);
        c[2] = addFe2(t[3], t[1]);
        t[4] = addFe2(b0, b1);
        t[3] = addFe2(a[0], a[1]);
        t[4] = mulFe2(t[4], t[3]);
        t[4] = subFe2(t[4], t[0]);
        c[1] = subFe2(t[4], t[1]);
        c[0] = addFe2(t[2], t[0]);
        return c;
    }

    static function mulBy1Fe6(fe6 a, fe2 b1) : fe6 {
        fe6 c = Fe6Zero;
        fe2 [6]t = Fe2_6Zero;

        t[0] = mulFe2(a[2], b1);
        c[2] = mulFe2(a[1], b1);
        c[1] = mulFe2(a[0], b1);
        c[0] = mulByNonResidueFe2(t[0]);
        return c;
    }

    static function squareFe12(fe12 a) : fe12 {
        fe12 c = Fe12Zero;
        fe6 [4]t = repeat(Fe6Zero, 4);

        t[0] = addFe6(a[0], a[1]);
        t[2] = mulFe6(a[0], a[1]);
        t[1] = mulByNonResidueFe6(a[1]);
        t[1] = addFe6(t[1], a[0]);
        t[3] = mulByNonResidueFe6(t[2]);
        t[0] = mulFe6(t[0], t[1]);
        t[0] = subFe6(t[0], t[2]);
        c[0] = subFe6(t[0], t[3]);
        c[1] = doubleFe6(t[2]);

        return c;
    }

    static function mulBy014AssignFe12(fe12 a, fe2 c0, fe2 c1, fe2 c4) : fe12 {
        fe6 [5]t = repeat(Fe6Zero, 5);
        fe2 t2 = Fe2Zero;

        t[0] = mulBy01Fe6(a[0], c0, c1);
        t[1] = mulBy1Fe6(a[1], c4);
        t2 = addFe2(c1, c4);
        t[2] = addFe6(a[1], a[0]);
        t[2] = mulBy01Fe6(t[2], c0, t2);
        t[2] = subFe6(t[2], t[0]);
        a[1] = subFe6(t[2], t[1]);
        t[1] = mulByNonResidueFe6(t[1]);
        a[0] = addFe6(t[1], t[0]);
        return a;
    }

    //--------------------- for finalExp()

    static function fp4Square(fe2 c0, fe2 c1, fe2 a0, fe2 a1) : fe2[2] {
        fe2 [9]t = G2Zero;

        t[0] = squareFe2(a0);
        t[1] = squareFe2(a1);
        t[2] = mulByNonResidueFe2(t[1]);
        c0 = addFe2(t[2], t[0]);
        t[2] = addFe2(a0, a1);
        t[2] = squareFe2(t[2]);
        t[2] = subFe2(t[2], t[0]);
        c1 = subFe2(t[2], t[1]);

        return [c0, c1];
    }

    static function mulByBaseFieldFe6(fe6 a, fe2 b) : fe6 {
        fe6 c = Fe6Zero;

        c[0] = mulFe2(a[0], b);
        c[1] = mulFe2(a[1], b);
        c[2] = mulFe2(a[2], b);

        return c;
    }

    static function squareFe6(fe6 a) : fe6 {
        fe6 c = Fe6Zero;
        fe2 [6]t = Fe2_6Zero;

        t[0] = squareFe2(a[0]);
        t[1] = doubleFe2(mulFe2(a[0], a[1]));
        t[2] = squareFe2(addFe2(subFe2(a[0], a[1]), a[2]));
        t[3] = doubleFe2(mulFe2(a[1], a[2]));
        t[4] = squareFe2(a[2]);
        t[5] = mulByNonResidueFe2(t[3]);

        c[0] = addFe2(t[0], t[5]);
        t[5] = mulByNonResidueFe2(t[4]);
        c[1] = addFe2(t[1], t[5]);
        t[1] = addFe2(t[1], t[2]);
        t[1] = addFe2(t[1], t[3]);
        t[0] = addFe2(t[0], t[4]);
        c[2] = subFe2(t[1], t[0]);

        return c;
    }

    static function inverseFe6(fe6 a) : fe6 {
        fe6 c = Fe6Zero;
        fe2 [6]t = Fe2_6Zero;

        t[0] = squareFe2(a[0]);
        t[1] = mulByNonResidueFe2(mulFe2(a[1], a[2]));
        t[0] = subFe2(t[0], t[1]);
        t[1] = squareFe2(a[1]);
        t[2] = mulFe2(a[0], a[2]);
        t[1] = subFe2(t[1], t[2]);
        t[2] = mulByNonResidueFe2(squareFe2(a[2]));
        t[3] = mulFe2(a[0], a[1]);
        t[2] = subFe2(t[2], t[3]);
        t[3] = mulFe2(a[2], t[2]);
        t[4] = mulFe2(a[1], t[1]);
        t[3] = mulByNonResidueFe2(addFe2(t[3], t[4]));
        t[4] = mulFe2(a[0], t[0]);
        t[3] = inverseFe2(addFe2(t[3], t[4]));
        c[0] = mulFe2(t[0], t[3]);
        c[1] = mulFe2(t[2], t[3]);
        c[2] = mulFe2(t[1], t[3]);

        return c;
    }

    static function inverseFe12(fe12 a) : fe12 {
        fe12 c = Fe12Zero;
        fe6 [2]t = repeat(Fe6Zero, 2);

        t[0] = squareFe6(a[0]);
        t[1] = mulByNonResidueFe6(squareFe6(a[1]));
        t[1] = subFe6(t[0], t[1]);
        t[0] = inverseFe6(t[1]);

        c[0] = mulFe6(a[0], t[0]);
        t[0] = mulFe6(t[0], a[1]);
        c[1] = negFe6(t[0]);

        return c;
    }

    static function cyclotomicSquare(fe12 a) : fe12 {
        fe12 c = Fe12Zero;
        fe2 [9]t = G2Zero;
        fe2 [2] d = repeat(Fe2Zero, 2);

        d = fp4Square(t[3], t[4], a[0][0], a[1][1]);
        t[3] = d[0];
        t[4] = d[1];
        t[2] = subFe2(t[3], a[0][0]);
        t[2] = doubleFe2(t[2]);
        c[0][0] = addFe2(t[2], t[3]);        
        t[2] = addFe2(t[4], a[1][1]);
        t[2] = doubleFe2(t[2]);
        c[1][1] = addFe2(t[2], t[4]); 
        d = fp4Square(t[3], t[4], a[1][0], a[0][2]);
        t[3] = d[0];
        t[4] = d[1];
        d = fp4Square(t[5], t[6], a[0][1], a[1][2]);
        t[5] = d[0];
        t[6] = d[1];
        t[2] = subFe2(t[3], a[0][1]);
        t[2] = doubleFe2(t[2]);
        c[0][1] = addFe2(t[2], t[3]);        
        t[2] = addFe2(t[4], a[1][2]);
        t[2] = doubleFe2(t[2]);
        c[1][2] = addFe2(t[2], t[4]);   
        t[3] = mulByNonResidueFe2(t[6]);
        t[2] = addFe2(t[3], a[1][0]);
        t[2] = doubleFe2(t[2]);
        c[1][0] = addFe2(t[2], t[3]);   
        t[2] = subFe2(t[5], a[0][2]);
        t[2] = doubleFe2(t[2]);
        c[0][2] = addFe2(t[2], t[5]);   
        return c;
    }

    //1101 0010 0000 0001 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000
    static function cyclotomicExp2(fe12 a) : fe12 {
        fe12 z = oneFe12();

        // z = cyclotomicSquare(z);
        // z = mulFe12(z, a);
        z = cyclotomicSquare(a);
        z = mulFe12(z, a);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = mulFe12(z, a);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = mulFe12(z, a);
        z = cyclotomicSquare(z);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = mulFe12(z, a);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = mulFe12(z, a);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);

        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);
        z = cyclotomicSquare(z);

        return z;
    }

    static function frobeniusMapFe2(fe2 a, fe power) : fe2 {
        fe2 c = Fe2Zero;

        c[0] = a[0];
        if(power % 2 == 1) {
            c[1] = mod(a[1] * -1, P);
        } else {
            c[1] = a[1];
        }
        
        return c;
    }

    static function frobeniusMapFe6(fe6 a, fe power) : fe6 {
        fe6 c = Fe6Zero;
        int tt = 0;

        c[0] = frobeniusMapFe2(a[0], power);
        c[1] = frobeniusMapFe2(a[1], power);
        c[2] = frobeniusMapFe2(a[2], power);

        int w = power % 6;
        if(w == 3) {
            tt = mod(c[1][1] * -1, P);
            c[1][1] = c[1][0];
            c[1][0] = tt;
            c[2] = negFe2(c[2]);
        } else if(w != 0) {
            c[1] = mulFe2(c[1], frobeniusCoeffs61[w]);
            c[2] = mulFe2(c[2], frobeniusCoeffs62[w]);
        }

        return c;
    }

    static function frobeniusMapFe12(fe12 a, fe power) : fe12 {
        fe12 c = Fe12Zero;

        c[0] = frobeniusMapFe6(a[0], power);
        c[1] = frobeniusMapFe6(a[1], power);

        if(power == 6) {
            c[1] = negFe6(c[1]);
        } else if(power != 0) {
            c[1] = mulByBaseFieldFe6(c[1], frobeniusCoeffs12[power]);
        }

        return c;
    }

    //--------------------- 
    static function IsZeroG1(PointG1 c) : bool {
        return c[2] == 0;
    }

    static function IsAffineG1(PointG1 p) : bool {
        return p[2] == BLS12381.r1;
    }

    static function AffineG1(PointG1 p) : PointG1 {
        PointG1 res = p;

        if(IsZeroG1(p) == false) {
            if(IsAffineG1(p) == false) {
                G1 t = G1Zero;
                t[0] = inverse(p[2]);
                t[1] = squareFe(t[0]);
                p[0] = mulFe(p[0], t[1]);
                t[0] = mulFe(t[0], t[1]);
                p[1] = mulFe(p[1], t[0]);
                p[2] = r1;

                res = p;
            }
        }
        return res;
    }

    // http://www.hyperelliptic.org/EFD/gp/auto-shortw-jacobian-0.html#addition-add-2007-bl
    static function AddG1(PointG1 p1, PointG1 p2) : PointG1 {
        PointG1 res = PtG1Zero;
        G1 t = G1Zero;

    	if(IsZeroG1(p1)) {
		    res = p2;
        } else if(IsZeroG1(p2)) {
		    res = p1;
        } else {
            t[7] = squareFe(p1[2]);
            t[1] = mulFe(p2[0], t[7]);
            t[2] = mulFe(p1[2], t[7]);
            t[0] = mulFe(p2[1], t[2]);
            t[8] = squareFe(p2[2]);
            t[3] = mulFe(p1[0], t[8]);
            t[4] = mulFe(p2[2], t[8]);
            t[2] = mulFe(p1[1], t[4]);

            if(t[1] == t[3]) {
                if(t[0] == t[2]) {
                    res = DoubleG1(p1);
                } else {
                    res = [0, r1, 0];
                }
            } else {
                t[1] = mod(t[1] - t[3], P);
                t[4] = mod(t[1] << 1, P);
                t[4] = squareFe(t[4]);
                t[5] = mulFe(t[1], t[4]);
                t[0] = mod(t[0] - t[2], P);
                t[0] = mod(t[0] << 1, P);
                t[6] = squareFe(t[0]);
                t[6] = mod(t[6] - t[5], P);
                t[3] = mulFe(t[3], t[4]);
                t[4] = mod(t[3] << 1, P);
                res[0] = mod(t[6] - t[4], P);
                t[4] = mod(t[3] - res[0], P);
                t[6] = mulFe(t[2], t[5]);
                t[6] = mod(t[6] << 1, P);
                t[0] = mulFe(t[0], t[4]);
                res[1] = mod(t[0] - t[6], P);
                t[0] = mod(p1[2] + p2[2], P);
                t[0] = squareFe(t[0]);
                t[0] = mod(t[0] - t[7], P);
                t[0] = mod(t[0] - t[8], P);
                res[2] = mulFe(t[0], t[1]);
            }
        }

        return res;
    }

	// http://www.hyperelliptic.org/EFD/gp/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
    static function DoubleG1(PointG1 p) : PointG1 {
        PointG1 res = PtG1Zero;
        G1 t = G1Zero;

    	if(IsZeroG1(p)) {
		    res = p;
        } else {
            t[0] = squareFe(p[0]);
            t[1] = squareFe(p[1]);
            t[2] = squareFe(t[1]);
            t[1] = mod(p[0] + t[1], P);
            t[1] = squareFe(t[1]);
            t[1] = mod(t[1] - t[0], P);
            t[1] = mod(t[1] - t[2], P);
            t[1] = mod(t[1] << 1, P);
            t[3] = mod(t[0] << 1, P);
            t[0] = mod(t[3] + t[0], P);
            t[4] = squareFe(t[0]);
            t[3] = mod(t[1] << 1, P);
            res[0] = mod(t[4] - t[3], P);
            t[1] = mod(t[1] - res[0], P);
            t[2] = mod(t[2] << 1, P);
            t[2] = mod(t[2] << 1, P);
            t[2] = mod(t[2] << 1, P);
            t[0] = mulFe(t[0], t[1]);
            t[1] = mod(t[0] - t[2], P);
            t[0] = mulFe(p[1], p[2]);
            res[1] = t[1];
            res[2] = mod(t[0] << 1, P);
        }

        return res;
    }

    static function NegG1(PointG1 p) : PointG1 {
        return [p[0], mod(-p[1], P), p[2]];
    }

    static function MulScalarG1(PointG1 a, int e) : PointG1  {
        PointG1 res = [0, 1, 0];
        if (e != 0) {
            PointG1 t = PtG1Zero;
            PointG1 sum = PtG1Zero;
            bytes mb = reverseBytes(num2bin(e, S), S);
            bytes mm = b'00';
            bool firstOne = false;

            loop(256) : i {
                if (firstOne) {
                    t = DoubleG1(sum);
                }

                mm = mask << (255 - i);
                if ((mb & mm) != zero) {
                    firstOne = true;
                    sum = AddG1(t, a);
                } else {
                    sum = t;
                }
            }
            res = sum;
        }
        return res;
    }

    //--------------------- 
    static function ZeroG2() : PointG2 {
        return [zeroFe2(), oneFe2(), zeroFe2()];
    }

    static function IsZeroG2(PointG2 p) : bool {
        return isZeroFe2(p[2]);
    }

    static function IsAffineG2(PointG2 p) : bool {
        return isOneFe2(p[2]);
    }

    static function AffineG2(PointG2 p) : PointG2 {
        PointG2 res = p;

        if(IsZeroG2(p) == false) {
            if(IsAffineG2(p) == false) {
                G2 t = G2Zero;
                t[0] = inverseFe2(p[2]);
                t[1] = mulFe2(t[0], t[0]);
                p[0] = mulFe2(p[0], t[1]);
                t[0] = mulFe2(t[0], t[1]);
                p[1] = mulFe2(p[1], t[0]);
                p[2] = [r1, 0];

                res = p;
            }
        }
        return res;
    }
}

"#;

    let pairing_lib = r#"
struct Pair {PointG1 g1; PointG2 g2;}

library BLS12381Pairing {
    // 2 ^ (-1)
    static const fe twoInv = 0x17fbb8571a006596d3916126f2d14ca26e22d1ec31ebb502633cb57c253c276f855000053ab000011804000000015554;

    static const int x = 0xd201000000010000;
    static const bytes X = b'd201000000010000';
    static const bytes MASK = b'0000000000000001';
    static const bytes ZERO = b'0000000000000000';

    static const fe2 [10]Fe2_10Zero = repeat(BLS12381.Fe2Zero, 10);

    static function affinePair(PointG1 g1, PointG2 g2) : Pair {
        Pair pr = {BLS12381.PtG1Zero, BLS12381.Fe6Zero};
        if((BLS12381.IsZeroG1(g1) || BLS12381.IsZeroG2(g2)) == false) {
            pr = {BLS12381.AffineG1(g1), BLS12381.AffineG2(g2)};
        }
        return pr;
    }

    // Adaptation of Formula 3 in https://eprint.iacr.org/2010/526.pdf
    static function doublingStep(fe2 [3]coeff, PointG2 r) : fe12 {
        fe2 [10]t = Fe2_10Zero;
        fe6 rr = BLS12381.Fe6Zero;

        t[0] = BLS12381.mulFe2(r[0], r[1]);
        t[0] = BLS12381.mulByFqFe2(t[0], twoInv);
        t[1] = BLS12381.squareFe2(r[1]);
        t[2] = BLS12381.squareFe2(r[2]);
        t[7] = BLS12381.doubleFe2(t[2]);
        t[7] = BLS12381.addFe2(t[7], t[2]);
        t[3] = BLS12381.mulByBFe2(t[7]);
        t[4] = BLS12381.doubleFe2(t[3]);
        t[4] = BLS12381.addFe2(t[4], t[3]);
        t[5] = BLS12381.addFe2(t[1], t[4]);
        t[5] = BLS12381.mulByFqFe2(t[5], twoInv);
        t[6] = BLS12381.addFe2(r[1], r[2]);
        t[6] = BLS12381.squareFe2(t[6]);
        t[7] = BLS12381.addFe2(t[2], t[1]);
        t[6] = BLS12381.subFe2(t[6], t[7]);
        coeff[0] = BLS12381.subFe2(t[3], t[1]);
        t[7] = BLS12381.squareFe2(r[0]);
        t[4] = BLS12381.subFe2(t[1], t[4]);

        rr[0] = BLS12381.mulFe2(t[4], t[0]);

        t[2] = BLS12381.squareFe2(t[3]);
        t[3] = BLS12381.doubleFe2(t[2]);
        t[3] = BLS12381.addFe2(t[3], t[2]);
        t[5] = BLS12381.squareFe2(t[5]);
        rr[1] = BLS12381.subFe2(t[5], t[3]);
        rr[2] = BLS12381.mulFe2(t[1], t[6]);
        t[0] = BLS12381.doubleFe2(t[7]);
        coeff[1] = BLS12381.addFe2(t[0], t[7]);
        coeff[2] = BLS12381.negFe2(t[6]);

        return [coeff, rr];
    }

    // Algorithm 12 in https://eprint.iacr.org/2010/526.pdf
    static function additionStep(fe2[3] coeff, PointG2 r, PointG2 q) : fe12 {
        fe2 [10]t = Fe2_10Zero;

        t[0] = BLS12381.mulFe2(q[1], r[2]);
        t[0] = BLS12381.negFe2(t[0]);
        t[0] = BLS12381.addFe2(t[0], r[1]);
        t[1] = BLS12381.mulFe2(q[0], r[2]);
        t[1] = BLS12381.negFe2(t[1]);
        t[1] = BLS12381.addFe2(t[1], r[0]);
        t[2] = BLS12381.squareFe2(t[0]);
        t[3] = BLS12381.squareFe2(t[1]);
        t[4] = BLS12381.mulFe2(t[1], t[3]);
        t[2] = BLS12381.mulFe2(r[2], t[2]);
        t[3] = BLS12381.mulFe2(r[0], t[3]);
        t[5] = BLS12381.doubleFe2(t[3]);
        t[5] = BLS12381.subFe2(t[4], t[5]);
        t[5] = BLS12381.addFe2(t[5], t[2]);

        r[0] = BLS12381.mulFe2(t[1], t[5]);
        t[2] = BLS12381.subFe2(t[3], t[5]);
        t[2] = BLS12381.mulFe2(t[2], t[0]);
        t[3] = BLS12381.mulFe2(r[1], t[4]);
        r[1] = BLS12381.subFe2(t[2], t[3]);
        r[2] = BLS12381.mulFe2(r[2], t[4]);
        t[2] = BLS12381.mulFe2(t[1], q[1]);
        t[3] = BLS12381.mulFe2(t[0], q[0]);
        coeff[0] = BLS12381.subFe2(t[3], t[2]);
        coeff[1] = BLS12381.negFe2(t[0]);
        coeff[2] = t[1];

        return [coeff, r];
    }

    // Algorithm 5 in  https://eprint.iacr.org/2019/077.pdf
    // 101 0010 0000 0001 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000;
    static function preCompute(fe6[68] ellCoeffs, PointG2 twistPoint) : fe6[68] {
        if(BLS12381.IsZeroG2(twistPoint) == false) {
            PointG2 r = twistPoint;
            int j = 0;

            fe12 rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;
            rtn = additionStep(ellCoeffs[j], r, twistPoint);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;
            rtn = additionStep(ellCoeffs[j], r, twistPoint);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;
            rtn = additionStep(ellCoeffs[j], r, twistPoint);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;
            rtn = additionStep(ellCoeffs[j], r, twistPoint);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;
            rtn = additionStep(ellCoeffs[j], r, twistPoint);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
            r = rtn[1];
            j++;

            rtn = doublingStep(ellCoeffs[j], r);
            ellCoeffs[j] = rtn[0];
        }

        return ellCoeffs;
    }

    // 101 0010 0000 0001 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000;
    static function millerLoop(PointG1 g1, PointG2 g2) : fe12 {
        fe6[68] ellCoeffs = repeat(BLS12381.Fe6Zero, 68);
        
        ellCoeffs = preCompute(ellCoeffs, g2);

        fe12 f = BLS12381.oneFe12();
        fe2 [2]t2 = repeat(BLS12381.Fe2Zero, 2);
        int j = 0;

        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        j++;

        f = BLS12381.squareFe12(f);
        t2[0] = BLS12381.mulByFqFe2(ellCoeffs[j][2], g1[1]);
        t2[1] = BLS12381.mulByFqFe2(ellCoeffs[j][1], g1[0]);
        f = BLS12381.mulBy014AssignFe12(f, ellCoeffs[j][0], t2[1], t2[0]);
        // j++;

        f = BLS12381.conjugateFe12(f);
        return f;
    }


    static function expPair(fe12 a) : fe12 {
        // fe12 c = BLS12381.cyclotomicExp(a, x);
        fe12 c = BLS12381.cyclotomicExp2(a);
        c = BLS12381.conjugateFe12(c);
        return c;
    }

    static function finalExp(fe12 f) : fe12 {
        fe12 [9]t = repeat(BLS12381.Fe12Zero, 9);

        t[0] = BLS12381.frobeniusMapFe12(f, 6);

        t[1] = BLS12381.inverseFe12(f);

        t[2] = BLS12381.mulFe12(t[0], t[1]);
        t[1] = t[2];
        t[2] = BLS12381.frobeniusMapFe12(t[2], 2);
        t[2] = BLS12381.mulFe12(t[2], t[1]);
        t[1] = BLS12381.cyclotomicSquare(t[2]);
        t[1] = BLS12381.conjugateFe12(t[1]);

        // hard part
        t[3] = expPair(t[2]);

        t[4] = BLS12381.cyclotomicSquare(t[3]);
        t[5] = BLS12381.mulFe12(t[1], t[3]);
        t[1] = expPair(t[5]);
        t[0] = expPair(t[1]);
        t[6] = expPair(t[0]);

        t[6] = BLS12381.mulFe12(t[6], t[4]);
        t[4] = expPair(t[6]);
        t[5] = BLS12381.conjugateFe12(t[5]);
        t[4] = BLS12381.mulFe12(t[4], t[5]);
        t[4] = BLS12381.mulFe12(t[4], t[2]);
        
        t[5] = BLS12381.conjugateFe12(t[2]);
        t[1] = BLS12381.mulFe12(t[1], t[2]);
        t[1] = BLS12381.frobeniusMapFe12(t[1], 3);
        t[6] = BLS12381.mulFe12(t[6], t[5]);
        t[6] = BLS12381.frobeniusMapFe12(t[6], 1);

        t[3] = BLS12381.mulFe12(t[3], t[0]);
        t[3] = BLS12381.frobeniusMapFe12(t[3], 2);
        t[3] = BLS12381.mulFe12(t[3], t[1]);
        t[3] = BLS12381.mulFe12(t[3], t[6]);
        f = BLS12381.mulFe12(t[3], t[4]);
        return f;
    }

    // Check three pairs.
    // millerb1a1 + A * B + inputs * (-gamma) + C * (-delta) == 1
    static function pairCheck3Point(
            PointG1 a0, PointG2 b0,
            fe12 millerb1a1,
            PointG1 a2, PointG2 b2,
            PointG1 a3, PointG2 b3) : bool {

        fe12 f2 = BLS12381.Fe12Zero;
        fe12 f3 = BLS12381.Fe12Zero;
        fe12 f0 = BLS12381.Fe12Zero;
        fe12 acc = BLS12381.Fe12Zero;

        Pair pair = affinePair(a2, b2);
        f2 = millerLoop(pair.g1, pair.g2);

        pair = affinePair(a3, b3);
        f3 = millerLoop(pair.g1, pair.g2);

        pair = affinePair(a0, b0);
        f0 = millerLoop(BLS12381.NegG1(pair.g1), pair.g2);

        acc = BLS12381.mulFe12(millerb1a1, f2);
        acc = BLS12381.mulFe12(acc, f3);
        acc = BLS12381.mulFe12(acc, f0);

        acc = finalExp(acc);

        return BLS12381.isOneFe12(acc);
    }
}

"#;

    [
        bls12_381_lib,
        pairing_lib,
    ]
    .join("\n")
}